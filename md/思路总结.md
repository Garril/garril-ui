# Garril-UI开发思路

<hr/>

## 组件文件目录结构

```css
以button组件为例，其他组件也都差不多
button
	src
		(像form可能有form-item，就在这里开一个components文件夹)
		button.tsx
		button-type.ts
	style
		button-config.scss
		button.scss
		button-base.scss
	test
		button.test.ts
	index.ts
```



## 概念学习

<hr/>

### 库模式

```css
https://vitejs.dev/guide/build.html#library-mode
```

当你开发面向浏览器的库时，你可能会将大部分时间花在该库的测试/演示页面上。

在 Vite 中你可以使用 `index.html` 获得如丝般顺滑的开发体验。

当这个库要进行发布构建时，请使用 [`build.lib` 配置项](https://cn.vitejs.dev/config/build-options.html#build-lib)，

以确保将那些你不想打包进库的依赖进行外部化处理，例如 `vue` 或 `react`：

#### vite.config.js

```js
// vite.config.js
import { resolve } from 'path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: { // 设置lib指定一个入口，rollup将来打包这个入口文件，输出我们想要的东西
      // Could also be a dictionary or array of multiple entry points
      entry: resolve(__dirname, 'lib/main.js'),
      name: 'MyLib',
      // the proper extensions will be added
      fileName: 'my-lib',
    },
    rollupOptions: {
      // 确保外部化处理那些你不想打包进库的依赖
      external: ['vue'],
      output: {
        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})

```

#### lib/main.js

```ts
// lib/main.js
import Foo from './Foo.vue'
import Bar from './Bar.vue'
export { Foo, Bar }
```

使用如上配置运行 `vite build` 时，将会使用一套**面向库的 Rollup 预设**，

并且将为该库提供两种构建格式：`es` 和 `umd` (可在 `build.lib` 中配置)：

```ts
$ vite build
building for production...
dist/my-lib.js      0.08 KiB / gzip: 0.07 KiB
dist/my-lib.umd.cjs 0.30 KiB / gzip: 0.16 KiB
```

之后在package.json中这样设置，即可

```json
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.umd.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.umd.cjs"
    }
  }
}
```

如果只是要生成组件库的话，直接用库模式就可以做了。

但是我们希望手动的去编写rollup的配置，有更好的控制能力，所以有了**打包**部分的scripts



### public目录

`public `目录是存放静态资源的一种方式。

项目初始化时默认`public`作为静态资源服务的文件夹。我们可以在`vite.config.js`中修改`publicDir为false`（就不会生成）。

该目录中的文件开发期间在 `/` 处提供，（在开发时我们可以使用`/`开头直接访问`public` 目录下的资源）

```css
public
	resources
		icon
		images

<img class="header" src="/resources/images/header.png"/>
```

并在构建期间将`public`文件夹下的文件（不包含`public`本身）复制到outDir 的根目录。

`public`下的文件会被完整复制到目标目录的根目录下，保持原有文件名，不会被`hash`。

**当项目部署在嵌套的公共路径下，我们需要指定 `base` 配置项**，

由 `JS` 引入的资源 `URL`，`CSS` 中的 `url()` 引用以及 `.html` 文件中引用的资源在构建过程中都会自动调整，以适配此选项。

```json
{
  alias: {
    "@": resolve(__dirname, "./src"),
  },
  base: "/admin/"
}

构建前
<img class="header" src="/resources/images/header.png"/>
构建后
<img class="header" src="/admin/resources/images/header.png"/>
```

当访问过程中需要使用动态连接的 `url` 时，不能被自动调整，

可以使用全局注入的 `import.meta.env.BASE_URL` 变量，它的值为公共基础路径



<hr/>

## cli配置

### 安装依赖

在项目的src同级目录下创建文件夹cli

（之后cli的运行，必须进入到cli文件夹去敲命令行）

![image-20230316164226136](https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230316164226136.png)

```css
在cli下，npm init
创建对应目录，执行 npm i -g ts-node-dev （开发工具，后续可以node跑ts）
```

ts-node-dev 是基于node-dev 做的一个用于ts-node 服务重启工具

相较于`node-dev -r ts-node/register ...`, `nodemon -x ts-node ...` 这些同类工具来说，

由于其不需要每次重新实例化 `ts-node 编译器 `，所以拥有更快的重新启动速度。

```css
源码解析： https://juejin.cn/post/7165675624810414087
下图： 执行ts-node-dev src/index.ts 时的执行流程
```

![image-20230316165548366](https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230316165548366.png)

```css
安装其他依赖
yarn add -D commander inquirer fs-extra kolorist
可以看到package.json有显示对应依赖
  "devDependencies": {
    "@types/fs-extra": "^11.0.1",
    "commander": "^9.2.0",
    "fs-extra": "^10.1.0",
    "inquirer": "^8.2.2",
    "kolorist": "^1.5.1"
  }
```

### package.json

```json
{
  "name": "cli",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "@dev": "tsnd ./src/index.ts create",
    "build": "tsc",
    "dev": "tsc --watch",
    "cli": "node ./build/src/index.js create"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/fs-extra": "^11.0.1",
    "commander": "^9.2.0",
    "fs-extra": "^10.1.0",
    "inquirer": "^8.2.2",
    "kolorist": "^1.5.1"
  }
}
```

### cli / src / index.ts

```ts
// yarn cli 的执行文件
import { Command } from 'commander'
import createActionCB from '../command/create'

// 创建一个命令对象
const cmd = new Command()
// 注册命令、参数，以及用户传入之后的回调函数
// $tsnd ./src/index.ts create --type component
cmd
  .command('create') // package.json中要运行就要 create
  // 命令描述
  .description('创建一个组件的配置文件')
  // 命令参数 -t 或 --type
  // <type> 必填， [type] 选填
  .option('-t --type <type>', '创建类型可选值: component, lib-entry')
  // 注册回调函数
  .action(createActionCB)
// 执行命令行参数解析
cmd.parse()

// 看上面package.json的@dev，可以执行命令yarn @dev -t 组件类型名
// 实现命令行交互，拿到用户输入的组件名，传入回调函数createActionCB中
```

直接执行命令 `tsnd ./src/index.ts create -t button` 报错`Cannot use import statement outside a module`（node跑的不是cjs，有毛病）

因为我们使用的是ts，ts要被转义为js，被转译后需要一个最终的格式和目标，所以需要设置tsconfig.json文件，如下：

### tsconfig.json

```json
{
  "compilerOptions": {
    "outDir": "./build",
    "module": "commonjs" // 约定打包最终模块的方式，组织代码模块的方式，应该是cjs而不是esm
  }
}
```

### cli / command / create.ts（createActionCB）

```ts
// inquirer 生成选项列表,让用户去选择type
// 只适用于nodejs，只有cjs格式, 8.2.2 用 * as 解决
import * as inquirer from 'inquirer'

// 用户type输入错误，爆红提示
import { red } from 'kolorist'
import createCpn from '../shared/create-cpn'
// 常量
import { CREATE_TYPES, DOCS_CATEGORIES } from '../src/constant'

export default async function createActionCB(args = { type: '' }) {
  // args: { type: 'xxx' } 拿到组件名
  let { type } = args
  /*
  	const res = await inquirer.prompt()接收一个对象数组，每个对象就代表要填的一项
  	而对象中的属性含义如下：
    name变量的名字，赋值到res属性中，res.xxx
  	type交互方式，list让你选，input让你输入
  	message提示信息
    choices如果是list，让你选的列表
    default如果是list，默认选项，是input就是默认值
  */
  // 没输入type
  if (!type) {
    const res = await inquirer.prompt([
      {
        // 获取属性名称
        name: 'type',
        // 交互方式
        type: 'list',
        // 提示信息
        message: '(必填) 请选择创建类型: ',
        // 选项列表
        choices: CREATE_TYPES, // 看src/constant.js  -->  ['component', 'lib-entry']
        // 默认选项
        default: 0
      }
    ])
    type = res.type

    // 输入type错误,要求重新输入
  } else if (!CREATE_TYPES.includes(type)) {
    console.log(
      red(
        `当前类型仅支持: ${CREATE_TYPES.join(
          ', '
        )}\n您输入的为: ${type}, 请重新选择!`
      )
    )
    return createActionCB()
  }
  // 创建文件相关内容
  try {
    switch (type) {
      case 'component':
        // 1、我们还需要收集: 要创建的组件的相关信息
        const info = await inquirer.prompt([
          {
            name: 'name',
            type: 'input',
            message: '(必填) 请输入组件的name, 将用作文件以及文件夹的名称: ',
            validate(value: string) {
              if (value.trim() === '') {
                return '组件name不能为空！'
              }
              // 校验通过
              return true
            }
          },
          {
            name: 'title',
            type: 'input',
            message:
              '(必填) 请输入组件的中文名称, 将用作组件在文档列表中的名称: ',
            validate(value: string) {
              if (value.trim() === '') {
                return '组件名称不能为空！'
              }
              // 校验通过
              return true
            }
          },
          {
            name: 'category',
            type: 'list',
            message: '(必填) 请选择组件的分类, 将用作文档列表的分类: ',
            choices: DOCS_CATEGORIES,
            default: 0
          }
        ])
        // 2、拿到info，创建组件文件
        createCpn(info)
        break
      case 'lib-entry':
        // 这里没做
        
        break
      default:
        break
    }
  } catch (err) {
    console.log(red(err)) // 用了kolorist
  }
}

```

可以看到在上面 81、82行，我们将拿到的info传入了下面的createCpn函数中

（ 通过 command，我们可以输入命令行， 开启终端的交互，进行数据的输入。但是用户可能输入错误，或者输入的不是我们要的

那么这个时候，我们就需要利用 inquirer，让用户去选择，选完后获取到的所有信息，在info对象中。

把info对象传入给 create-cpn，这个函数会利用template和info属性，生成文件目录和文件

在现实的时候，用了kolorist，去做颜色的显示，提高交互体验）

### cli / shared / create-cpn.ts

#### 核心思路

```ts
// 核心的几个api和思路
import { resolve } from 'path'
const { name } = info
// 拼接组件目录
const cpnDir = resolve('../src', name)
// 组件目录下的文件的dir
const cpnSrcDir = resolve(cpnDir, 'src')
const styleDir = resolve(cpnDir, 'style')
const testDir = resolve(cpnDir, 'test')
// 创建文件夹
ensureDirSync(cpnSrcDir/styleDir/test/Dir)
// 文件和内容创建
const cpnFilePath = resolve(cpnSrcDir/styleDir/testDir, name + '.tsx/-type.ts/.scss/.test.ts')
writeFileSync(cpnFilePath, genCpnTemplate(name), WRITE_FILE_OPTIONS)
// writeFileSync(文件路径，对应内容-name传入生成template，写入的格式{ encoding: 'utf-8' } )

// 组件索引文件
const indexFilePath = cpnDir + `/index.ts`
writeFileSync(indexFilePath, genIndexTemplate(name), WRITE_FILE_OPTIONS)

// 创建成功通知
console.log(
  lightGreen(`
        ✔️ 组件${name}目录创建生成
    `)
)
console.log(
  lightBlue(`
        ✔️ 组件目录：${cpnSrcDir}
    `)
)
```

#### 具体实现

```ts
import { ensureDirSync, writeFileSync } from 'fs-extra'
import { resolve } from 'path'
import { lightBlue, lightGreen } from 'kolorist'

import genCpnTemplate from '../template/src/cpn'
import genTypesTemplate from '../template/src/types'
import genStyleTemplate from '../template/style/style'
import genTestTemplate from '../template/test/test'
import genIndexTemplate from '../template'

import { WRITE_FILE_OPTIONS } from '../src/constant'

export interface CpnInfo {
  name: string
  title: string
  category: string
}

export default function createCpn(info: CpnInfo) {
  const { name } = info
  // 这里可以对name做一个命名的规范处理....
  // 拼接组件目录
  const cpnDir = resolve('../src', name)
  // 组件目录下的文件的dir
  const cpnSrcDir = resolve(cpnDir, 'src')
  const styleDir = resolve(cpnDir, 'style')
  const testDir = resolve(cpnDir, 'test')
  // 创建文件夹
  ensureDirSync(cpnSrcDir)
  ensureDirSync(styleDir)
  ensureDirSync(testDir)

  // 文件和内容创建
  // 核心文件：组件文件
  const cpnFilePath = resolve(cpnSrcDir, name + '.tsx')
  writeFileSync(cpnFilePath, genCpnTemplate(name), WRITE_FILE_OPTIONS)

  // 核心文件：组件类型文件
  const typesFilePath = resolve(cpnSrcDir, name + '-type.ts')
  writeFileSync(typesFilePath, genTypesTemplate(name), WRITE_FILE_OPTIONS)

  // 核心文件：组件样式文件
  // const styleFilePath = styleDir + `/${name}.scss`
  const styleFilePath = resolve(styleDir, name + '.scss')
  writeFileSync(styleFilePath, genStyleTemplate(name), WRITE_FILE_OPTIONS)

  // 核心文件：测试文件
  // const testFilePath = testDir + `/${name}.test.ts`
  const testFilePath = resolve(testDir, name + '.test.ts')
  writeFileSync(testFilePath, genTestTemplate(name), WRITE_FILE_OPTIONS)

  // 组件索引文件
  const indexFilePath = cpnDir + `/index.ts`
  writeFileSync(indexFilePath, genIndexTemplate(name), WRITE_FILE_OPTIONS)

  // 创建成功通知
  console.log(
    lightGreen(`
        ✔️ 组件${name}目录创建生成
    `)
  )
  console.log(
    lightBlue(`
        ✔️ 组件目录：${cpnSrcDir}
    `)
  )
}

```

### src / constant.js

```ts
import { WriteFileOptions } from 'fs-extra'

// 创建类型
export const CREATE_TYPES: string[] = ['component', 'lib-entry']
// 组件分类
export const DOCS_CATEGORIES: string[] = [
  '通用',
  '导航',
  '反馈',
  '数据录入',
  '数据展示',
  '布局'
]
export const WRITE_FILE_OPTIONS: WriteFileOptions = { encoding: 'utf-8' }
```

### cli / template

首先看看 template文件夹下目录结构，其实和实际初始化出来的组件目录结构差不多

#### 目录结构

```css
template
    src
        cpn.ts
        types.ts
    style
        style.ts
    test
        test.ts
    index.ts
		utils.ts
```

#### utils

```ts
// 首字母大写
export function upperFirstLetter(str: string) {
  return str[0].toUpperCase() + str.slice(1)
}
```

#### cpn.ts

```ts
import { upperFirstLetter } from '../utils'
// 创建组件核心文件模板
export default function genCpnTemplate(name: string) {
  const cpnName = 'G' + upperFirstLetter(name)
  const className = 's-' + name
  const propsName = name + 'Props'
  const propsTypeName = upperFirstLetter(name) + 'Props'
  const propsFileName = name + '-type'
  return `
import { defineComponent } from 'vue'
import { ${propsTypeName}, ${propsName} } from './${propsFileName}'

export default defineComponent({
  name: '${cpnName}',
  props: ${propsName},
  setup(props: ${propsTypeName}) {
    return () => {
      return <div class="${className}"></div>
    }
  }
})  
`
}
```



#### types.ts

```ts
import { upperFirstLetter } from '../utils'
// 创建组件属性类型声明文件模板
export default function genTypesTemplate(name: string) {
  // 属性类型声明和属性类型
  const propsTypeName = upperFirstLetter(name) + 'Props'
  const propsName = name + 'Props'

  return `\
import { ExtractPropTypes, PropType } from 'vue'

export const ${propsName} = {} as const
export type ${propsTypeName} = ExtractPropTypes<typeof ${propsName}>
`
}
```



#### style.ts

```ts
export default function genStyleTemplate(name) {
  return `\
.s-${name} {
}
`
}
```



#### test.ts

```ts
import { upperFirstLetter } from '../utils'

export default function genTestTemplate(name) {
  return `\
import { render } from '@testing-library/vue'
import ${upperFirstLetter(name)} from '../src/${name}'

describe('${name} test', () => {
  test('${name} init render', async () => {
    const { getByRole } = render(${upperFirstLetter(name)})
    getByRole('${name}')
  })
})
`
}
```

#### index.ts

```ts
import { upperFirstLetter } from './utils'

export default function genIndexTemplate(name) {
  const cpnName = upperFirstLetter(name)
  return `\
import { App } from 'vue'
import ${cpnName} from './src/${name}'

// 具名导出
export { ${cpnName} }

// 导出插件
export default {
  install(app: App) {
    app.component(${cpnName}.name, ${cpnName})
  }
}
`
}
```



<hr/>

## 打包

看之前，先看概念（库模式）

### 文件目录结构

src同级目录scripts下

```css
scripts
      build.cjs
      entry.ts
src
      assets
      button
      xxx
```



### 写脚本（build.cjs/js）

```js
/* 将来这个是node去执行的，所以是js
  又因为整个组件库项目的vite.config文件中type="module", 使用require报错
  将所有require改为import也行，但__dirname的引入反而麻烦

	思路：从vite中require进 { defineConfig, build } 后
	写基础配置
		1、全量配置
		2、单文件配置
	生成build文件夹下的package.json		
	执行创建（执行build方法）
*/

const path = require('path')
const fs = require('fs')
const { defineConfig, build } = require('vite')

// 入口文件 -- 同级的entry.ts
const entryFile = path.resolve(__dirname, './entry.ts')
// 输出目录 -- 根目录的build文件夹
const outputDir = path.resolve(__dirname, '../build')
// 组件目录
const cpnsDir = path.resolve(__dirname, '../src')

// 基础配置
const vue = require('@vitejs/plugin-vue')
const vueJsx = require('@vitejs/plugin-vue-jsx')
const baseConfig = defineConfig({
  configFile: false, // 不需要配置文件
  publicDir: false, // 不需要public目录---用处：在上面概念public目录看
  plugins: [vue(), vueJsx()]
})

// rollup配置（设置格式）
const rollupOptions = {
  // 外置，将来不要把这些库打包到我们的组件库
  external: ['vue', 'vue-router'],
  output: { // 输出的格式是：IIFE/umd/global格式。
    globals: { // 希望有个全局变量叫vue，防止出问题
      vue: 'Vue'
    }
  }
}

// 执行创建
// 全量构建
const buildAll = async name => {
  await build(
    defineConfig({ // 做了个配置的合并
      ...baseConfig,
      build: {
        rollupOptions,
        lib: {
          entry: entryFile, // 组件库的入口文件
          name: name, // 包的名字
          fileName: name, // 文件的名字
          formats: ['es', 'umd'] // 格式
        },
        outDir: outputDir // 输出目录的设置
      }
    })
  )
  preSetPackageJson(name)
}
// 按需构建 (name: 组件/文件名)
const buildSingle = async name => {
  await build(
    defineConfig({
      ...baseConfig,
      build: {
        rollupOptions,
        lib: {
          entry: path.resolve(cpnsDir, name),
          name: 'index',
          fileName: 'index',
          formats: ['es', 'umd']
        },
        outDir: path.resolve(outputDir, name)
      }
    })
  )
  // 只打一个组件，不需要传参
  preSetPackageJson()
}

const buildLib = async () => {
  // 全量打包
  await buildAll('garril-ui')
  // 按需打包
  fs.readdirSync(cpnsDir)
    .filter(name => {
      // 要目录，且目录内还有index.ts文件
      // current path
      const filePath = path.resolve(cpnsDir, name)
      // is a folder?
      const isDir = fs.lstatSync(filePath).isDirectory()
      // folder contain the index?
      return isDir && fs.readdirSync(filePath).includes('index.ts')
    })
    .forEach(async name => {
      await buildSingle(name)
    })
}

// 生成build文件夹下的package.json --- 函数preSetPackageJson的定义： 看下面

buildLib()
```

#### 生成package.json

```ts
// 生成build文件夹下的package.json （为什么要生成？看下面 ）
const fsExtra = require('fs-extra') // 操作文件系统的一个库
const version = require('../package.json').version // 拿到整个项目的package.json中的version字段
const preSetPackageJson = name => {
  // 预设
  const fileStr = `{
    "name": "${name ? name : 'garril-ui'}",
    "version": "${version}",
    "main": "${name ? 'index.umd.js' : 'garril-ui.umd.js'}",
    "module": "${name ? 'index.umd.js' : 'garril-ui.es.js'}",
    "author": "Garril",
    "description": "Practice building a cpn store",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/Garril/garril-ui"
    },
    "keywords": ["vue3", "组件库", "tsx", "UI", "scss", "vite"],
    "license": "ISC",
    "bugs": {
      "url": "https://github.com/Garril/garril-ui/issues"
    }
  }`
  /*
  	看上面的module 和 main，一个是es一个是umd。
  	如果我们以后导入方式是webpack、vite、rollup，就是用的es
  	如果是浏览器、src的方式，就是用的main
  
  */
  if (name) {
    // 单个组件，输出对应的package.json
    fsExtra.outputFile(
      path.resolve(outputDir, 'config/package.json'),
      fileStr,
      'utf-8'
    )
  } else {
    // 全量
    fsExtra.outputFile(
      path.resolve(outputDir, 'package.json'),
      fileStr,
      'utf-8'
    )
  }
}
```

#### 如何使用打包后文件（测试下）

（在还没有自己调函数生成 package.json的情况下）

在项目`package.json`中写命令

```ts
"build:cpns":"node ./scripts/build.js"
```

执行命令

```css
yarn build:cpns
```

发现在根目录下有 `garril-ui.js 和 garril-ui.umd.js` （ 可能是 xxx.es.js 和 xxx.umd.js ，这里的garril-ui是传入的name ）

因为在入口（看下面的设置入口），我们export default的是一个插件

所以我们可以在 整个项目的` main.ts` 中 

```ts
import GarrilUI from '../build/garril-ui.js'
createApp(App).use(GarrilUI).mount('#app')
```



#### 为什么要自己生成package.json?

首先解决 为什么要在build文件下生成package.json 的问题？

因为package.json相当于和打包工具进行交流。通过配置他，我们之后可以直接通过组件库的名字，去导入组件库

而不是通过import一个js文件路径

```ts
import GarrilUI from 'garril-ui'
```

然后解决 为什么不写死一个package.json在build文件夹的问题？

因为写死了，只对下一次打包有效，打包后，package.json就被覆盖销毁了



### 设置入口（entry.ts）

```ts
// 入口文件
// scripts/entry.ts
import type { App } from 'vue'
// 1、引入实现的组件
import ButtonPlugin, { Button } from '../src/button'
import xxxPlugin,{ xxx } from '../src/xxx'
// .......

// 2、批量导出组件
export { Button, xxx }
const pluginList = [ButtonPlugin, xxxPlugin]

// 3、导出vue插件
export default {
  install(app: App) {
    pluginList.forEach(plugin => {
      app.use(plugin)
    })
  }
}
```



### 入口具名导出所有组件



### 编写插件导出



<hr/>

## 测试





<hr/>

## 组件开发

