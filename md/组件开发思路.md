# Garril-UI组件开发思路

<hr/>



## 组件文件目录结构

<hr/>

```css
以button组件为例，其他组件也都差不多
button
	src
		(像form可能有form-item，就在这里开一个components文件夹)
		button.tsx
		button-type.ts
	style
		button-config.scss
		button.scss
		button-base.scss
	test
		button.test.ts
	index.ts
```



## 组件内容案例 ( button )

<hr/>

以button为例子，展示其组件各个文件大致设计

### / src / button.tsx

```tsx
import { defineComponent, toRefs } from 'vue'
import { ButtonProps, buttonProps } from './button-type'

export default defineComponent({
  name: 'GButton',
  props: buttonProps,
  setup(props: ButtonProps, { slots }) {
    const { type, size, disabled, block } = toRefs(props)
    return () => {
      const defaultSlot = slots.default ? slots.default() : '按钮'
      const blockClass = block.value ? 's-btn--block' : ''
      return (
        <button
          disabled={disabled.value}
          class={`s-btn s-btn--${type.value} s-btn--${size.value} ${blockClass}`}
        >
          {defaultSlot}
        </button>
      )
    }
  }
})

```

### / src / button-type.ts

```ts
import { ExtractPropTypes, PropType } from 'vue'

export type IButtonType = 'primary' | 'secondary' | 'text'
export type IButtonSize = 'small' | 'medium' | 'large'

// button中的props定义
export const buttonProps = {
  type: {
    type: String as PropType<IButtonType>,
    default: 'secondary'
  },
  size: {
    type: String as PropType<IButtonSize>,
    default: 'medium'
  },
  disabled: {
    type: Boolean,
    default: false
  },
  block: {
    type: Boolean,
    default: false
  }
}

// 利用值反推出Button属性类型
export type ButtonProps = ExtractPropTypes<typeof buttonProps>
```

### / style / button.scss

```scss
// button.scss
@use './button-config.scss';
@import './button-base.scss';

.s-btn {
  @include button-base;
  // 导入type相关的样式
  @include button-variant(button-config.$type);
  // 导入size相关的样式
  @include button-variant(button-config.$size);
  // 导入hover等伪类
  @include button-variant(button-config.$pseudo, true);
}
```

### / style / button-base.scss

```scss
// button-base.scss
@import '../../style/variable.scss'; // scss变量定义文件 --- 全局style目录下

@mixin button-base {
  // 布局
  @apply inline-flex items-center justify-center;
  // 元素
  @apply border-[1px] border-solid border-transparent
  h-[28px] py-0 px-[20px]
  bg-transparent;
  border-radius: $s-border-radius;

  // 文本属性
  @apply outline-0 leading-normal whitespace-nowrap
    cursor-pointer;

  // 文字样式
  font-size: $s-font-size-md;

  // 其他样式
  transition: background-color $s-animation-duration-slow
      $s-animation-ease-in-out-smooth,
    border-color $s-animation-duration-slow $s-animation-ease-in-out-smooth,
    color $s-animation-duration-slow $s-animation-ease-in-out-smooth;

  // 禁用状态
  &[disabled] {
    @apply cursor-not-allowed;
  }

  &.s-btn--block {
    @apply block w-full;
  }
  &.s-btn--loading {
    // @apply
  }
}

@mixin button-variant($variant, $pseudo: false) {
  @each $key, $value in $variant {
    // 第一层是多态的类型
    &.s-btn--#{$key} {
      @each $item-key, $item-value in $value {
        // 第二层是多态类型下的样式
        @if $pseudo {
          // 如果是伪类就继续第三层
          &:#{$item-key} {
            @each $sub-item-key, $sub-item-value in $item-value {
              // 第三层是伪类的样式
              #{$sub-item-key}: $sub-item-value;
            }
          }
        } @else {
          // 不是伪类就直接设置样式
          #{$item-key}: $item-value;
        }
      }
    }
  }
}
```

### / style / button-config.scss

```scss
// button-config.scss
// 所有不同type按钮自定义样式
@import '../../style/variable.scss';

// 按钮类型的配置
$type: (
  primary: (
    color: $s-light-text,
    background-color: $s-primary
  ),
  secondary: (
    color: $s-text,
    background-color: $s-block,
    border-color: $s-line
  ),
  text: (
    padding: 0,
    color: $s-brand-active
  )
);

// 伪类的配置
$pseudo: (
  primary: (
    hover: (
      background-color: $s-primary-hover
    ),
    focus: (
      background-color: $s-primary-hover
    ),
    active: (
      background-color: $s-primary-active
    ),
    disabled: (
      color: $s-light-text,
      background-color: $s-primary-disabled,
      border: none
    )
  ),
  secondary: (
    hover: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    focus: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    active: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    disabled: (
      color: $s-disabled-text,
      background-color: $s-disabled-bg,
      border: 1px solid $s-disabled-line
    )
  ),
  text: (
    hover: (
      color: $s-brand-active-focus
    ),
    focus: (
      color: $s-brand-active-focus
    ),
    active: (
      color: $s-brand-active-focus
    ),
    disabled: (
      color: $s-disabled-text
    )
  )
);

// 按钮尺寸
$size: (
  small: (
    height: 24px,
    padding: 0 16px,
    font-size: $s-font-size-sm
  ),
  medium: (
    font-size: $s-font-size-md
  ),
  large: (
    height: 32px,
    padding: 0 24px,
    font-size: $s-font-size-lg
  )
);
```

### / test /  button.test.ts

```ts
import { render } from '@testing-library/vue'
import Button from '../src/button'

// base button
test('test base button,without anything passed', () => {
  const { getByRole } = render(Button)
  getByRole('button')
})
// type
// button type defalut should be secondary
test('test button default type', () => {
  const { getByRole } = render(Button)
  const button = getByRole('button')
  expect(button.classList.contains('s-btn--secondary')).toBe(true)
})
// test button pass props type
test('test button pass props type', () => {
  const { getByRole } = render(Button, {
    props: {
      type: 'primary'
    }
  })
  const button = getByRole('button')
  expect(button.classList.contains('s-btn--primary')).toBe(true)
})

// slot
// slot default should be right
test('test slot default should be right', () => {
  const { getByText } = render(Button)
  getByText('按钮')
})
// slot should work
test('slot should work', () => {
  const { getByText } = render(Button, {
    slots: {
      default() {
        return 'inslot'
      }
    }
  })
  getByText('inslot')
})

```

###  / index.ts

```ts
import { App } from 'vue'

import Button from './src/button'

// 具名导出
export { Button }

// 导出插件
export default {
  install(app: App) {
    app.component(Button.name, Button)
  }
}
```



## 整体的scss

### 安装tailwind

```scss
npm install -D tailwindcss
npx tailwindcss init
```

修改根目录下的`tailwind.config.js`文件

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  // Add the paths to all of your template files in your tailwind.config.js file.
  content: ['./public/index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  theme: {
    extend: {}
  },
  plugins: []
}
```

Add the Tailwind directives to your CSS。在根路径的 index.scss中（main.ts对index.scss做引入）

```scss
// @import "tailwindcss/base";
// @import "tailwindcss/components";
// @import "tailwindcss/utilities";
@tailwind base;
@tailwind components;
@tailwind utilities;
```



### $变量

在整个项目的`src/style/variable.scss`下

```scss
// 变量
$prefix: 's';
$spacing-3: 6px;
// 定义主题变量
$s-border-radius: var(--s-border-radius, 2px); //一般圆角
$s-font-size-sm: var(--s-font-size-md, 10px); //当组件size为''时使用此字号大小
// 使用变量
$size-mini: $size-6;
// 线性
$transition-timing-function-linear: cubic-bezier(0, 0, 1, 1);
```

用以上的方法定义了很多的变量，之后在其他的scss文件中可以引入，使用变量：

```scss
@import '../../style/variable.scss';
xxx {
  border-radius: $s-border-radius;
}
```

### mixin 

**用`mixin`定义样式块 `button-base ` ( 配合了 `tailwindcss `)**

```scss
@import '../../style/variable.scss';
@mixin button-base {
  // 布局
  @apply inline-flex items-center justify-center;
  // 元素
  @apply border-[1px] border-solid border-transparent
  h-[28px] py-0 px-[20px]
  bg-transparent;
  border-radius: $s-border-radius;

  // 文本属性
  @apply outline-0 leading-normal whitespace-nowrap
    cursor-pointer;

  // 文字样式
  font-size: $s-font-size-md;

  // 其他样式
  transition: background-color $s-animation-duration-slow
      $s-animation-ease-in-out-smooth,
    border-color $s-animation-duration-slow $s-animation-ease-in-out-smooth,
    color $s-animation-duration-slow $s-animation-ease-in-out-smooth;

  // 禁用状态
  &[disabled] {
    @apply cursor-not-allowed;
  }

  &.s-btn--block {
    @apply block w-full;
  }
  &.s-btn--loading {
    // @apply
  }
}
```

使用`button-base`

```scss
@import './button-base.scss';
.s-btn {
  @include button-base;
}
```

**用mixin定义函数**

```scss
@import '../../style/variable.scss';
@mixin button-variant($variant, $pseudo: false) {
  @each $key, $value in $variant {
    // 第一层是多态的类型
    &.s-btn--#{$key} {
      @each $item-key, $item-value in $value {
        // 第二层是多态类型下的样式
        @if $pseudo {
          // 如果是伪类就继续第三层
          &:#{$item-key} {
            @each $sub-item-key, $sub-item-value in $item-value {
              // 第三层是伪类的样式
              #{$sub-item-key}: $sub-item-value;
            }
          }
        } @else {
          // 不是伪类就直接设置样式
          #{$item-key}: $item-value;
        }
      }
    }
  }
}
```

使用 `button-variant`  函数

```scss
@use './button-config.scss';
@import './button-base.scss';

.s-btn {
  // 导入type相关的样式
  @include button-variant(button-config.$type);
  // 导入size相关的样式
  @include button-variant(button-config.$size);
  // 导入hover等伪类
  @include button-variant(button-config.$pseudo, true);
}
// 文件名如果不以下划线开头的话，sass会认为改文件是一个应用文件，不会将它转成css文件
//  @import "_main.css";
```

可以看到，这里面还有个`@use`和`button-config`变量

### @use

```scss
// 所有不同type按钮自定义样式
@import '../../style/variable.scss';
// 按钮类型的配置
$type: (
  primary: (
    color: $s-light-text,
    background-color: $s-primary
  ),
  secondary: (
    color: $s-text,
    background-color: $s-block,
    border-color: $s-line
  ),
  text: (
    padding: 0,
    color: $s-brand-active
  )
);
// 伪类配置
$pseudo: (
  primary: (
    hover: (
      background-color: $s-primary-hover
    ),
    focus: (
      background-color: $s-primary-hover
    ),
    active: (
      background-color: $s-primary-active
    ),
    disabled: (
      color: $s-light-text,
      background-color: $s-primary-disabled,
      border: none
    )
  ),
  secondary: (...),
  text: (...)
)
// 按钮尺寸
$size: (
  small: (
    height: 24px,
    padding: 0 16px,
    font-size: $s-font-size-sm
  ),
  medium: (...),
  large: (...)
);
```



## button

### props

首先 button 有 三种类型：

```ts
'primary' | 'secondary' | 'text'

export type IButtonType = 'primary' | 'secondary' | 'text'
type: {
  type: String as PropType<IButtonType>,
  default: 'secondary'
},
```

三种 大小 size：

```css
'small' | 'medium' | 'large'
```

能够控制，是否接收被点击：

```ts
disabled: {
  type: Boolean,
  default: false
}
```

如果是手机端，需要按钮够长，为一个 block

```ts
block: {
  type: Boolean,
  default: false
}
```

### code

```css
toRefs(props) 解构下，再把拿到的属性，根据逻辑需要，在tsx中处理
没有其他事件处理，没监听没emit
button按钮中显示的文字做个slot，其他无
```



## form

### 使用

```html
<GForm
  ref="loginFormRef"
  :model="model"
  layout="horizontal"
  :label-align="labelAlign"
  :label-size="labelSize"
  :rules="rules"
  @form-submit="onLogin"
>
  <GFormItem label="用户名：" field="user">
    <GInput v-model="model.user" />
  </GFormItem>
  <GFormItem label="密码：" field="password">
    <GInput v-model="model.password" type="password" />
  </GFormItem>
  <GFormItem>
    <button>登录</button>
  </GFormItem>
</GForm>

```

### props

```ts
import { Rules } from 'async-validator'
import { ExtractPropTypes, InjectionKey, PropType } from 'vue'
import { FormItemContext } from './components/form-item-type'
export type LayoutType = 'vertical' | 'horizontal'
export type LabelSizeType = 'sm' | 'md' | 'lg'
export type LabelAlignType = 'start' | 'center' | 'end'

export const formProps = {
  // 表单数据
  model: {
    type: Object,
    required: true
  },
  // layout、labelSize、labelAlign均为提供给form-item的值
  layout: {
    type: String as PropType<LayoutType>,
    default: 'vertical'
  },
  labelSize: {
    type: String as PropType<LabelSizeType>,
    default: 'md'
  },
  labelAlign: {
    type: String as PropType<LabelAlignType>,
    default: 'start'
  },
  // 校验规则
  rules: {
    type: Object as PropType<Rules>
  }
} as const
export type FormProps = ExtractPropTypes<typeof formProps>
// form组件provide给form-item的ctx类型（提供表单上下文 以及 全局校验）
export type FormContext = {
  model: any
  rules?: Rules
  addItem: (item: FormItemContext) => void
  deleteItem: (item: FormItemContext) => void
}
// 在他provide的时候进行强类型传递
export const formContextToken: InjectionKey<FormContext> =
  Symbol('formContextToken')

```



### code

```tsx
import { Value } from 'async-validator'
import { computed, defineComponent, provide, toRefs } from 'vue'
import { FormItemContext } from './components/form-item-type'
import { formContextToken, FormProps, formProps } from './form-type'

export default defineComponent({
  name: 'GForm',
  props: formProps,
  emits: ['form-submit'],
  setup(props: FormProps, { slots, emit, expose }) {
    const { model } = toRefs(props)
    // 提供 labelData
    const labelData = computed(() => ({
      layout: props.layout,
      labelSize: props.labelSize,
      labelAlign: props.labelAlign
    }))
    provide('LabelData', labelData)
    // 提供表单上下文 以及 全局校验
    const formItems = new Set<FormItemContext>()
    const addItem = (item: FormItemContext) => formItems.add(item)
    const deleteItem = (item: FormItemContext) => formItems.delete(item)
    provide(formContextToken, {
      model: props.model,
      rules: props.rules,
      addItem,
      deleteItem
    })
    const formSubmit = (event: Event) => {
      // 取消表单默认提交行为，防止页面刷新
      event.preventDefault()
      emit('form-submit')
    }
    const validateFormData = (cb: (isCheckSuccess: boolean) => void) => {
      const resArr: Array<Promise<Value>> = []
      formItems.forEach(item => resArr.push(item.validate()))
      Promise.all(resArr)
        .then(() => cb(true))
        .catch(() => cb(false))
    }
    // 对外暴露接口
    expose({
      validateFormData
    })
    return () => (
      <form class="s-form" onSubmit={formSubmit}>
        <div>{model.value.name}</div>
        <div>{slots.default?.()}</div>
      </form>
    )
  }
})

```





### form-item

#### 使用

```html
<GFormItem label="用户名: " field="user"></GFormItem>
```



#### props

```ts
import { Value } from 'async-validator'
import { ExtractPropTypes } from 'vue'
import { LabelAlignType, LabelSizeType, LayoutType } from '../form-type'

export const formItemProps = {
  // 提示label
  label: {
    type: String,
    default: ''
  },
  // 字段属性名
  field: {
    type: String
  }
} as const
export type FormItemProps = ExtractPropTypes<typeof formItemProps>

/*
  export type LayoutType = 'vertical' | 'horizontal'
  export type LabelSizeType = 'sm' | 'md' | 'lg'
  export type LabelAlignType = 'start' | 'center' | 'end'
*/
export type LabelDataType = {
  layout: LayoutType
  labelSize: LabelSizeType
  labelAlign: LabelAlignType
}
// 表单provide传下的对象，含校验方法
export type FormItemContext = {
  validate: () => Promise<Value>
}
```



#### code

```tsx
import {
  computed,
  ComputedRef,
  defineComponent,
  inject,
  onMounted,
  onUnmounted,
  provide,
  ref
} from 'vue'
import { formContextToken } from '../form-type'
import { FormItemProps, formItemProps, LabelDataType } from './form-item-type'
import Validator from 'async-validator'

export default defineComponent({
  name: 'GFormItem',
  props: formItemProps,
  setup(props: FormItemProps, { slots }) {
    const labelData = inject('LabelData') as ComputedRef<LabelDataType>
    const itemClasses = computed(() => ({
      's-form-item': true,
      's-form-item--horizontal': labelData.value.layout === 'horizontal',
      's-form-item--vertical': labelData.value.layout === 'vertical'
    }))
    const labelClass = computed(() => ({
      's-form-item-label': true,
      's-form-item-label--vertical': labelData.value.layout === 'vertical',
      /* 水平 才显示 */
      [`s-form-item-label--${labelData.value.labelAlign}`]:
        labelData.value.layout === 'horizontal',
      [`s-form-item-label--${labelData.value.labelSize}`]:
        labelData.value.layout === 'horizontal'
    }))
    const errorMessage = ref('')
    const showMessage = ref(false)
    // form提供，强类型传递，不需要进行断言
    const formCtx = inject(formContextToken)

    const validate = () => {
      if (!formCtx) {
        console.warn('请在Form中使用FormItem')
        return Promise.reject('请在Form中使用FormItem')
      }
      if (!props.field) {
        console.warn('请在FormItem中设置field字段')
        return Promise.reject('请在FormItem中设置field字段')
      }
      // 不需要校验规则
      if (!formCtx.rules) {
        return Promise.resolve({ result: true })
      }
      // 获取校验规则和数值
      const itemRules = formCtx.rules[props.field] || undefined
      if (!itemRules) {
        return Promise.resolve({ result: true })
      }
      const val = formCtx.model[props.field]
      // 校验，返回结果
      // 创建一个校验的实例
      const validator = new Validator({ [props.field]: itemRules })
      return validator.validate({ [props.field]: val }, err => {
        if (err) {
          showMessage.value = true
          errorMessage.value = err[0].message || '校验失败'
        } else {
          showMessage.value = false
          errorMessage.value = ''
        }
      })
    }
    const formItemCtx = { validate }
    provide('FORM_ITEM_CTX', formItemCtx)
    // 全表单校验
    onMounted(() => {
      if (props.field) {
        formCtx?.addItem(formItemCtx)
      }
    })
    onUnmounted(() => {
      if (props.field) {
        formCtx?.deleteItem(formItemCtx)
      }
    })
    return () => {
      return (
        <div class={itemClasses.value}>
          {/* label */}
          <span class={labelClass.value}>{props.label}</span>
          {/* control */}
          <div>{slots.default?.()}</div>
          {/* error */}
          {showMessage.value && (
            <div class="error-message">{errorMessage.value}</div>
          )}
        </div>
      )
    }
  }
})

```





## icon

### 使用

```vue
<!-- 以图标的方式，存到字体中 -->
<GIcon name="facebook" size="40" color="skyblue"></GIcon>
<GIcon name="react" size="30" color="red"></GIcon>
<GIcon name="react" size="30px" color="blue"></GIcon>
<GIcon name="vue" :size="30" color="green"></GIcon>

<!-- name传src -->
<span style="width: 50px; display: inline-block">
  <GIcon name="https://vitejs.dev/logo.svg" width="30"></GIcon>
</span>

<!-- 通过元件的方式引入到页面中，用svg显示（拓展性更强）-->
<GIcon
  element="react"
  size="30"
  color="red"
  style="display: inline-block"
  ></GIcon>
<GIcon
  element="vue"
  size="30px"
  color="blue"
  style="display: inline-block"
  ></GIcon>
<GIcon
  element="webpack"
  size="30px"
  color="blue"
  style="display: inline-block"
  ></GIcon>
```

### props

```ts
import { ExtractPropTypes, PropType } from 'vue'
export const iconProps = {
  name: {
    // icon-vue中的vue
    type: String,
    default: ''
  },
  prefix: {
    // 前缀
    type: String,
    default: 'icon'
  },
  size: {
    // type: String || Number, --- 错误用法,认为是 String
    // type: [String, Number], --- ts报错
    type: [String, Number] as PropType<string | number>,
    default: 'inherit'
  },
  color: {
    type: String,
    default: 'inherit'
  },
  // 元件名，比如vue、react
  element: {
    type: String,
    default: null
  }
} as const
export type IconProps = ExtractPropTypes<typeof iconProps>
```

### code

```tsx
import { computed, defineComponent, toRefs } from 'vue'
import { IconProps, iconProps } from './icon-type'
import '../style/iconfont.js'
import '../style/iconfont.css'

export default defineComponent({
  name: 'GIcon',
  props: iconProps,
  setup(props: IconProps, { attrs }) {
    const { prefix, name, color, element } = toRefs(props)
    // 根据类型，对size做转换
    const size = computed(() => {
      if (typeof props.size === 'string' && props.size !== 'inherit') {
        // 做个简单的格式判断 --- px结尾
        if (!props.size.endsWith('px')) {
          return props.size + 'px'
        }
      } else if (typeof props.size === 'number') {
        return props.size + 'px'
      }
      return props.size
    })
    // svg显示
    /* 
      可以看到我们需要在svg中拿到对应icon的元件，
      而元件，是从iconfont.js中拿到的，
      在我们从官网导出icon项目的时候，生成的js文件
    */
    const svgIcon = (
      <svg
        class="icon"
        style={{
          width: size.value,
          height: size.value
        }}
      >
        {/* <use xlink:href="#icon-vue" fill={color.value}></use> */}
        <use
          xlink:href={`#${prefix.value}-${element.value}`}
          fill={color.value}
        ></use>
      </svg>
    )
    /* 
      下面的 http/https需要事先拿到地址
      iconfont 需要在icon.scss或者iconfont.css中有对应的类的声明
      （实现方式：伪类 content）
    */
    // http/https图片资源
    const imgIcon = (
      <img
        src={props.name}
        style={{
          width: size.value,
          height: 'auto',
          objectFit: 'contain',
          verticalAlign: 'middle'
        }}
        {...attrs}
      ></img>
    )
    // iconfont
    const fontIcon = (
      <span
        class={[prefix.value + 'font', prefix.value + '-' + name.value]}
        style={{ fontSize: size.value, color: color.value }}
      ></span>
    )
    const icon = /http|https/.test(name.value) ? imgIcon : fontIcon
    // 针对外部在GIcon上设置width，希望能在icon上一直生效的问题：
    // 直接return icon，根组件会继承非属性特性，父的width会直接继承，放到icon上
    // 但是如果icon外面包了一层icon_container，width就会不生效。-继承到icon_container上了
    // 所以进行展开非属性特性。---  attrs
    return () => (element.value ? svgIcon : icon)
  }
})
```

上面一开始引入了

```tsx
import '../style/iconfont.js'
import '../style/iconfont.css'
```

这些去阿里巴巴的iconfont，自己创建一个项目，去收集图标

然后选择font class模式下载，解压就行（后面的`.ttf、.woff、.woff2、.json`也是这样来的）

<img src="https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230330230039534.png" alt="image-20230330230039534" style="zoom:80%;" />



## input

### 使用

```vue
<GInput v-model="model.username"/>
<GInput v-model="model.password" type="password" />
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const inputProps = {
  type: {
    type: String,
    default: 'text'
  },
  modelValue: {
    type: String,
    default: ''
  }
} as const
export type InputProps = ExtractPropTypes<typeof inputProps>
```

### code

可以看到除了做个` input`值的 `v-model`，以及`input`原生的`type`看`props`外

就中只有一个 `inject`注入的方法 `formItemCtx` --- `这里可以看form组件，主要用来做表单校验`

```tsx
export default defineComponent({
  name: 'GInput',
  props: inputProps,
  emits: ['update:modelValue'],
  setup(props: InputProps, { emit }) {
    // 注入校验方法
    const formItemCtx = inject('FORM_ITEM_CTX') as FormItemContext

    const onInputCB = (event: Event) => {
      const val = (event.target as HTMLInputElement).value
      /* 后续要做lazy处理 */
      emit('update:modelValue', val)
      formItemCtx.validate()
    }
    return () => {
      return (
        <div class="s-input-wrapper">
          <input
            class="s-input"
            type={props.type}
            value={props.modelValue}
            onInput={onInputCB}
          />
        </div>
      )
    }
  }
})



// scss
.s-input {
  margin: 5px 10px 0px 5px;
}
```



## modal

`modal`的`render`直接就是套了一个`base-modal`，而`base-modal`只有一个`slots.default()`

这下面的 `template header/footer`，都是在`modal`中定义的

可以看到，在用的时候，`header`有提供 `close` 函数，待改进：给`footer`也提供

不过控制是否显示隐藏，是从最外层传给`modal`的`visible`到`base-modal`中的`isShow`。

### 使用

```html
<GModal v-model="visible" title="提示" :show-close="false" align-center>
  <template #header="{ close }">
    <div class="my-header"
         style="display: flex;
                justify-content: space-between;
                padding: 0 20px">
      <h4>My slot title!</h4>
      <GButton type="danger" @click="close">Close</GButton>
    </div>
  </template>
  <span>this is a message!</span>
  <template #footer>
    <div>
      <GButton style="margin-right: 12px" @click="visible = false">quit</GButton>
      <GButton @click="visible = false">yes</GButton>
    </div>
  </template>
</GModal>
<GButton @click="open"></GButton>

<!-- script部分 -->
const visible = ref(false)
const open = () => {
  visible.value = true
}
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const modalProps = {
  modelValue: {
    // 是否展示
    type: Boolean,
    default: false
  },
  title: {
    // 标题
    type: String,
    default: ''
  },
  width: {
    // 弹框的宽度
    type: String,
    default: '30%'
  },
  showClose: {
    // 显示关闭 x
    type: Boolean,
    default: true
  },
  center: {
    // title居中 -- 没用slots.header的情况下
    type: Boolean,
    default: false
  },
  alignCenter: {
    // modal整体 竖直方向居中
    type: Boolean,
    default: false
  }
} as const
export type ModalProps = ExtractPropTypes<typeof modalProps>
```

### code

```tsx
import { defineComponent, toRefs } from 'vue'
import BaseModal from './components/base-modal'
import { ModalProps, modalProps } from './modal-type'

export default defineComponent({
  name: 'GModal',
  props: modalProps,
  emits: ['update:modelValue'],
  setup(props: ModalProps, { slots, emit }) {
    const { modelValue, title, width, showClose, center, alignCenter } =
      toRefs(props)
    const alignCenterStyle = alignCenter.value
      ? {
          marginTop: 0,
          top: '50%',
          transform: 'translateY(-50%)'
        }
      : {}
    return () => (
      <BaseModal
        class="s-modal"
        isShow={modelValue.value}
        onUpdate:isShow={() => {
          emit('update:modelValue')
        }}
      >
        <div
          class="s-modal-container"
          style={{ width: width.value, ...alignCenterStyle }}
        >
          {/* 标题title */}
          {slots.header ? (
            slots.header?.({
              close: () => {
                emit('update:modelValue', false)
              }
            })
          ) : (
            <div
              class="s-modal-header"
              style={{ textAlign: center.value ? 'center' : 'left' }}
            >
              {title.value}
              {/* 关闭modal的 X 号*/}
              {showClose.value && (
                <svg
                  onClick={() => {
                    emit('update:modelValue', false)
                  }}
                  class="s-modal-close"
                  viewBox="0 0 1024 1024"
                  width="16"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    fill="currentColor"
                    d="M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
                  ></path>
                </svg>
              )}
            </div>
          )}
          {/* 内容default */}
          <div class="s-modal-default">{slots.default?.()}</div>
          {/* 操作区footer */}
          <div class="s-modal-footer">{slots.footer?.()}</div>
        </div>
      </BaseModal>
    )
  }
})

```

### base-modal

#### 使用

```css
modal的render就是return了一个base-modal,具体使用看Modal即可
```

#### props

```ts
import { ExtractPropTypes } from 'vue'

export const baseModalProps = {
  isShow: {
    // 是否展示
    type: Boolean,
    default: false
  }
} as const
export type BaseModalProps = ExtractPropTypes<typeof baseModalProps>
```

#### code

```tsx
import { defineComponent, toRefs } from 'vue'
import { baseModalProps, BaseModalProps } from './base-modal-type'

export default defineComponent({
  name: 'GBaseModal',
  props: baseModalProps,
  emits: ['update:isShow'],
  setup(props: BaseModalProps, { slots, emit }) {
    const { isShow } = toRefs(props)
    return () => (
      <div>
        {isShow.value && (
          <div class="s-base-modal">
            {/* 透明遮罩 */}
            <div
              class="s-base-modal--mask"
              onClick={() => {
                emit('update:isShow', false)
              }}
            ></div>
            {/* 具体内容 */}
            {slots.default?.()}
          </div>
        )}
      </div>
    )
  }
})
```

#### scss 

```scss
.s-base-modal,
.s-base-modal--mask {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  z-index: 100;
}
.s-base-modal--mask {
  background-color: rgba(0, 0, 0, 0.6);
  z-index: -1;
}
```



## pagination

### 使用

其实下面的` pagination`和`pager`差别为：

`pagination` 比 `pager `多出了个 上一页和下一页的功能

```html
<GPagination v-model:curPageIndex="curIndex" :total="50"></GPagination>
<GPager :total="50" @update-pager-index="changeIndex"></GPager>
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const paginationProps = {
  total: {
    // data总条数
    type: Number,
    default: 10
  },
  pageSize: {
    // 每页最大条数
    type: Number,
    default: 5
  },
  pageCount: {
    // 底部显示的页数按钮 数量
    type: Number,
    default: 5
  },
  curPageIndex: {
    type: Number,
    default: 1
  }
} as const
export type PaginationProps = ExtractPropTypes<typeof paginationProps>
```

### code

```tsx
import { computed, defineComponent, onMounted, ref, toRefs, watch } from 'vue'
import Pager from './components/pager'
import { PaginationProps, paginationProps } from './pagination-type'

export default defineComponent({
  name: 'GPagination',
  props: paginationProps,
  emits: ['update:curPageIndex'],
  setup(props: PaginationProps, { emit }) {
    const { total, pageSize } = toRefs(props)
    const pagerRef = ref<InstanceType<typeof Pager>>()
    const calcTotalPage = computed(() => {
      return Math.ceil(total.value / pageSize.value)
    })
    const disablePre = computed(() =>
      pagerRef.value ? pagerRef.value.pageIndex < 2 : true
    )
    const disableNext = computed(() =>
      pagerRef.value ? pagerRef.value.pageIndex >= calcTotalPage.value : true
    )
    /* 可以知道，页面号是Pager组件，Pagination是加了外面的上一页和下一页
    	然后Pager中pageIndex改变，emit到Pagination，Pagination再emit -- update:curPageIndex
    	外面v-modal到Pagination组件上的数据变化了，相当于传入Pagination组件的props改变了
    	那么，这里就会反而再通过组件ref，去改变Pager中的index。
    	
    	这也是为什么，在Pager组件中，我没有直接在setup函数中去return我的jsx
    	而是return出去数据和方法，这样父组件Pagination才能通过ref来调用。
    	之前的jsx从新在render函数中写就行。
    */
    const changePageIndex = (val: any) => {
      emit('update:curPageIndex', val)
    }
    onMounted(() => {
      watch(
        () => props.curPageIndex,
        (newVal: number) => {
          if (pagerRef.value) {
            pagerRef.value.setPageIndex(newVal)
          }
        }
      )
    })
    return () => {
      return (
        <div class="s-pagination">
        // 上一页按钮
          <button
            onClick={() => pagerRef.value?.prePage(calcTotalPage.value)}
            disabled={disablePre.value}
          >
            上一页
          </button>
				// 页号按钮
          <Pager
            {...props}
            ref={pagerRef}
					// 当pageIndex变化，Pager就会emit发送updatePagerIndex事件
            onUpdatePagerIndex={(val: any) => changePageIndex(val)}
          ></Pager>
				 // 下一页按钮
          <button
            onClick={() => pagerRef.value?.nextPage(calcTotalPage.value)}
            disabled={disableNext.value}
          >
            下一页
          </button>
        </div>
      )
    }
  }
})

```



### pager

#### hooks

封装当前页面index的相关prepage、nextPage等方法

```ts
import { ref } from 'vue'

export default function usePage(defaultPageIndex = 1) {
  // page number
  const pageIndex = ref(defaultPageIndex)
  // set page number -- click numbers to jump
  const setPageIndex = (cur: number) => {
    pageIndex.value = cur
  }
  // jump how many pages to ( double arrow -- quick to or back )
  const jumpToPageIndex = (step: number, calcTotalPage?: number) => {
    let res = pageIndex.value + step
    if (calcTotalPage && res > calcTotalPage) {
      res = calcTotalPage
    } else if (res < 1) {
      res = 1
    }
    pageIndex.value = res
  }
  // previous page
  const prePage = (calcTotalPage: number) => {
    jumpToPageIndex(-1, calcTotalPage)
  }
  // next page
  const nextPage = (calcTotalPage: number) => {
    jumpToPageIndex(1, calcTotalPage)
  }
  return {
    pageIndex,
    setPageIndex,
    jumpToPageIndex,
    prePage,
    nextPage
  }
}
```



#### props

`pagination` 和 `pager`的`props`一样

```ts
import { ExtractPropTypes } from 'vue'
import { paginationProps } from '../pagination-type'

export const pagerProps = paginationProps
// total--data总条数、pageSize--每页最大条数、
// pageCount--底部显示的页数按钮 数量、curPageIndex--当前页码
export type PagerProps = ExtractPropTypes<typeof pagerProps>
```

#### code

```tsx
import { computed, defineComponent, toRefs, watch } from 'vue'
import usePage from '../hooks/use-page'
import { getCenterPage } from '../utils'
import { pagerProps, PagerProps } from './pager-type'

export default defineComponent({
  name: 'GPager',
  props: pagerProps,
  emits: ['updatePagerIndex'],
  setup(props: PagerProps, { emit }) {
    const { pageIndex, setPageIndex, jumpToPageIndex, nextPage, prePage } =
      usePage()
    const { total, pageSize, pageCount } = toRefs(props)
    // 计算当前多少页
    const calcTotalPage = computed(() => {
      // 向上取整
      return Math.ceil(total.value / pageSize.value)
    })
    // 当前显示在中间的页（不包含首页、末页）
    const centerPages = computed(() => {
      return getCenterPage(
        calcTotalPage.value,
        pageIndex.value,
        pageCount.value
      )
    })
    watch(
      () => pageIndex.value,
      newVal => {
        emit('updatePagerIndex', newVal)
      }
    )
    return {
      pageCount,
      calcTotalPage,
      centerPages,
      pageIndex,
      setPageIndex,
      jumpToPageIndex,
      nextPage,
      prePage
    }
  },
  render() {
    const {
      pageCount,
      calcTotalPage,
      centerPages,
      pageIndex,
      setPageIndex,
      jumpToPageIndex
    } = this
    // 别写箭头函数
    return (
      <ul class="s-pager">
       // 首页
        <li
          onClick={() => setPageIndex(1)}
          class={{ current: pageIndex === 1 }}
        >
          1
        </li>
				// 点击中间的...，就向前/向后跳5页，改变了pageIndex,进而
        // 触发了centerPages的变化，emit了事件updatePagerIndex
        {calcTotalPage > pageCount && pageIndex > Math.ceil(pageCount / 2) && (
          <li
            class="ellipsis_left"
            onClick={() => jumpToPageIndex(-5, calcTotalPage)}
          >
            ...
          </li>
        )}
        {centerPages.map(page => (
          <li
            onClick={() => setPageIndex(page)}
            class={{ current: pageIndex === page }}
          >
            {page}
          </li>
        ))}
        {calcTotalPage > pageCount &&
          pageIndex < calcTotalPage - Math.ceil(pageCount / 2) + 1 && (
            <li
              class="ellipsis_right"
              onClick={() => jumpToPageIndex(5, calcTotalPage)}
            >
              ...
            </li>
          )}
          // 末页
        {calcTotalPage > 1 && (
          <li
            onClick={() => setPageIndex(calcTotalPage)}
            class={{ current: pageIndex === calcTotalPage }}
          >
            {calcTotalPage}
          </li>
        )}
      </ul>
    )
  }
})
```

#### utils

```ts
export function getCenterPage(
  calcTotalPage: number, // 计算出的总页码
  pageIndex: number, // 当前页码
  pageCount: number // 底部显示的页数按钮 数量
) {
  // ！！！ 首页和尾页 两个按钮固定显示，且数组代表页码 ！！！
  // 所以0不要，而且末页页码不在数组中
  const totalPageArr = Array.from({ length: calcTotalPage }, (v, i) => i)
  // eg: calcTotalPage = 5 --> totalPageArr: [0,1,2,3,4]
  if (calcTotalPage <= pageCount) {
    // eg: calcTotalPage = 5，totalPageArr = [0,1,2,3,4], pageCount = 6
    // 要取 [2,3,4]，1是首页，5是末页
    // 全显示
    return totalPageArr.slice(2, calcTotalPage)
  } else {
    // 中位数
    const mid = Math.ceil(pageCount / 2) // 注意：是pageCount
    // totalPageArr = [0,1,2,3,4,5,6,7,8]，calcTotalPage = 9, pageCount = 7 --> mid = 4
    if (pageIndex <= mid) {
      // pageIndex = 2/3/4
      // 要取[2,3,4,5,6] ---> slice(2,7)
      // 左边全显示
      return totalPageArr.slice(2, pageCount)
    } else if (pageIndex >= calcTotalPage - mid + 1) {
      // pageIndex = 6/7/8 (与前面不同，前面1是首位不能取，这里8不是末尾可取)
      // 要取[4,5,6,7,8]  ---> slice(4,9)
      // 右边全显示
      return totalPageArr.slice(calcTotalPage - pageCount + 2, calcTotalPage)
    } else {
      // pageIndex = 5
      // 要取[3,4,5,6,7] ---> slice(3,8)
      // 中间显示
      return totalPageArr.slice(pageIndex - mid + 2, pageIndex + mid - 1)
    }
  }
}

```



## popover

### 使用

```html
<div @click="changePopState" style="border: 1px solid red" ref="hostDom">
  change pop state
</div>
<GPopOver v-model="isPopShow" :host-dom="hostDom" title="标题">
  <div style="white-space: nowrap">content in the popover</div>
</GPopOver>

<!--
  const isPopShow = ref(false)
  const hostDom = ref()
  const changePopState = () => {
    isPopShow.value = !isPopShow.value
  }
-->
```



### props

```ts
import { Placement } from '@floating-ui/dom'
import { ExtractPropTypes, PropType } from 'vue'

export const popoverProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  hostDom: {
    type: Object as PropType<HTMLElement>,
    default: null
  },
  title: {
    type: String,
    default: ''
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  placement: {
    type: String as PropType<Placement>,
    default: 'bottom'
  }
} as const
export type PopoverProps = ExtractPropTypes<typeof popoverProps>

```

### code

```tsx
import { defineComponent, toRefs } from 'vue'
import { PopoverProps, popoverProps } from './popover-type'
import BasePopover from './components/base-popover'

export default defineComponent({
  name: 'GPopOver',
  props: popoverProps,
  emits: ['update:modalValue'],
  setup(props: PopoverProps, { slots }) {
    const { modelValue, title } = toRefs(props)

    return () => (
      <>
        {modelValue.value && (
          <BasePopover class="s-popover" {...props}>
            <h4 class="s-popover-title">{title.value}</h4>
            {slots.default?.()}
          </BasePopover>
        )}
      </>
    )
  }
})

```

### scss

```scss
.s-base-popover {
  position: absolute;
  background-color: #fff;
  border: 1px solid #626262;
  z-index: 10;
  min-width: 100px;
  min-height: 16px;
  
  &--arrow {
    position: absolute;
    background: #ffffff;
    width: 8px;
    height: 8px;
    transform: rotate(45deg);
    z-index: -1;
    border: 1px solid #e4e7ed;
  }
}
.s-popover {
  background: #ffffff;
  border: 1px solid #e4e7ed;
  border-radius: 4px;
  padding: 12px;
  box-shadow: 0 0 12px rgba(0,0,0,.12);
  width: 200px;
  
  &-title {
    color: #303133;
    font-size: 16px;
    margin-bottom: 12px;
  }
}
```



### base-popover

#### props

```ts
import { Placement } from '@floating-ui/dom'
import { ExtractPropTypes, PropType } from 'vue'

export const basePopoverProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  hostDom: {
    type: Object as PropType<HTMLElement>,
    default: null
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  placement: {
    type: String as PropType<Placement>,
    default: 'bottom'
  }
} as const
export type BasePopoverProps = ExtractPropTypes<typeof basePopoverProps>

```

#### code

```tsx
import { computePosition, arrow, offset, autoPlacement } from '@floating-ui/dom'
import { defineComponent, nextTick, onUnmounted, ref, toRefs, watch } from 'vue'
import { BasePopoverProps, basePopoverProps } from './base-popover-type'

export default defineComponent({
  name: 'GBasePopOver',
  props: basePopoverProps,
  emits: ['update:modalValue'],
  setup(props: BasePopoverProps, { slots, attrs }) {
    const { modelValue, hostDom, showArrow, placement } = toRefs(props)

    // 箭头ref
    const arrowRef = ref()
    // 气泡卡片
    const overlayRef = ref()

    // 计算定位
    const updatePosition = () => {
      const middleware = []
      if (showArrow.value) {
        middleware.push(offset(8))
        middleware.push(arrow({ element: arrowRef.value }))
      }
      // 用户如果没有设置placement，依靠autoPlacement中间件，做个自动调整定位
      if (!placement.value) {
        middleware.push(autoPlacement())
      }
      // 在滚动、窗口尺寸、宿主元素的位置大小发生变化。这3种情况下，需要重新自动调整定位
      computePosition(hostDom.value, overlayRef.value, {
        middleware,
        placement: placement.value || 'bottom'
      }).then(({ x, y, middlewareData, placement }) => {
        Object.assign(overlayRef.value.style, {
          left: x + 'px',
          top: y + 'px'
        })
        if (showArrow.value) {
          const { x: arrowX, y: arrowY } = middlewareData.arrow!
          // 箭头的偏移量 和 border哪条边设置透明，需要一个映射表
          /* 获取当前所在边 (placement拿到当前定位的值，用外面placement.value也可)
            比如我现在拿到了 top-end */
          const currentSide = placement.split('-')[0]
          const staticSide = {
            // 反方向，气泡卡片在宿主bottom位置，箭头就应该是指向top
            top: 'bottom',
            bottom: 'top',
            left: 'right',
            right: 'left'
          }[currentSide]
          // 算法
          const SIDE = ['top', 'right', 'bottom', 'left']
          const preIndex = (SIDE.indexOf(currentSide) + 4 - 1) % 4
          const nextSide = SIDE[preIndex]
          // left和top计算之后，需要重新计算 箭头 的位置
          Object.assign(arrowRef.value.style, {
            left: arrowX + 'px',
            top: arrowY + 'px',
            [staticSide!]: '-4px',
            [`border-${currentSide}-color`]: 'transparent',
            [`border-${nextSide}-color`]: 'transparent'
          })
        }
      })
    }

    // 创建mutationserver监听宿主元素的状态变化
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const mutationObserver = new MutationObserver(entries => {
      // entries可以拿到变化的项，做相应的，粒度更小的更新，可优化
      updatePosition()
    })

    watch(
      modelValue,
      newVal => {
        if (newVal) {
          nextTick(updatePosition)
          // 监听两个事件 以及宿主元素尺寸、定位变化
          hostDom.value &&
            mutationObserver.observe(hostDom.value, { attributes: true })
          window.addEventListener('resize', updatePosition)
          window.addEventListener('scroll', updatePosition)
        } else {
          mutationObserver.disconnect()
          window.removeEventListener('resize', updatePosition)
          window.removeEventListener('scroll', updatePosition)
        }
      },
      {
        immediate: true
      }
    )
    // popover频繁的弹出和销毁
    onUnmounted(() => {
      mutationObserver.disconnect()
      window.removeEventListener('resize', updatePosition)
      window.removeEventListener('scroll', updatePosition)
    })

    return () => (
      <>
        {modelValue.value && (
          <div ref={overlayRef} class="s-base-popover" {...attrs}>
            {/* 箭头 */}
            {showArrow.value && (
              <div class="s-base-popover--arrow" ref={arrowRef}></div>
            )}
            {/* 弹窗内容 */}
            {slots.default?.()}
          </div>
        )}
      </>
    )
  }
})

```



## tabs

### 使用

```html
<GTabs v-model="curTab" close-able add-able>
  <GTabItem id="home" title="home">首页</GTabItem>
  <GTabItem id="radio" title="radio">视频</GTabItem>
  <GTabItem id="article" title="article">文章</GTabItem>
  <GTabItem id="profile" title="profile">个人</GTabItem>
</GTabs>
<!--
	const curTab = ref('home')
-->
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const tabsProps = {
  modelValue: {
    type: String,
    default: ''
  },
  closeAble: {
    type: Boolean,
    default: false
  },
  addAble: {
    type: Boolean,
    default: false
  }
} as const
export type TabsProps = ExtractPropTypes<typeof tabsProps>

export type TabDataType = Array<{
  title: string
  id: string
  type?: 'dynamic'
  content?: string
}>

```



### code

```tsx
import { defineComponent, provide, ref } from 'vue'
import { randomId } from './utils'
import { TabDataType, TabsProps, tabsProps } from './tabs-type'

export default defineComponent({
  name: 'GTabs',
  props: tabsProps,
  emits: ['update:modelValue'],
  setup(props: TabsProps, { slots, emit }) {
    // tab选项卡可选的数据
    const tab_data = ref<TabDataType>([])
    provide('TAB_DATA', tab_data)

    // 当前active的tab
    const activeTab = ref<string>(props.modelValue)
    // 提供activeTab
    provide('CUR_ACTIVE_TAB', activeTab)

    // 切换了tab
    const changeActiveTab = (id: string) => {
      activeTab.value = id
      emit('update:modelValue', id)
    }
    /* 
      这里，我们需要data是一个数组，但是不是写死的，要动态生成的
      然而我们的数据(id和title属性)，是直接传入tab-item，
      需要从他那里去拿,所以provide，inject一个数组，让子组件push
    */
    const idSet = ref<Set<string>>(new Set())
    provide('SET_FOR_TEST', idSet)

    // 关闭/删除 tab页的方法
    const closeTab = (id: string) => {
      if (tab_data.value.length > 1) {
        const index = tab_data.value.findIndex(item => item.id === id)
        if (index !== -1) {
          activeTab.value = id
          tab_data.value.splice(index, 1)
          idSet.value.delete(id)
        }
      } else {
        console.warn('至少保留一个选项卡...')
      }
    }
    // 添加tab页的方法
    const newId = ref<string>('')
    const newContent = ref<string>('')
    const addTab = () => {
      newId.value = randomId(4)
      newContent.value = randomId(20)
      tab_data.value.push({
        id: newId.value,
        title: 'new tab',
        content: newContent.value,
        type: 'dynamic'
      })
      activeTab.value = newId.value
    }

    return () => (
      <div class="s-tabs">
        {/* tab栏 */}
        <ul class="s-tabs-ul">
          {tab_data.value.map(tab => {
            return (
              <li
                class={tab.id === activeTab.value ? 's-tabs-li-active' : ''}
                onClick={() => changeActiveTab(tab.id)}
              >
                {tab.title}
                {/* 关闭选项卡的按钮 */}
                {props.closeAble && (
                  <svg
                    onClick={() => closeTab(tab.id)}
                    style="margin-left: 8px;"
                    viewBox="0 0 1024 1024"
                    width="12"
                    height="12"
                  >
                    <path d="M610.461538 500.184615l256-257.96923c11.815385-11.815385 11.815385-29.538462 0-41.353847l-39.384615-41.353846c-11.815385-11.815385-29.538462-11.815385-41.353846 0L527.753846 417.476923c-7.876923 7.876923-19.692308 7.876923-27.569231 0L242.215385 157.538462c-11.815385-11.815385-29.538462-11.815385-41.353847 0l-41.353846 41.353846c-11.815385 11.815385-11.815385 29.538462 0 41.353846l257.969231 257.969231c7.876923 7.876923 7.876923 19.692308 0 27.56923L157.538462 785.723077c-11.815385 11.815385-11.815385 29.538462 0 41.353846l41.353846 41.353846c11.815385 11.815385 29.538462 11.815385 41.353846 0L498.215385 610.461538c7.876923-7.876923 19.692308-7.876923 27.56923 0l257.969231 257.969231c11.815385 11.815385 29.538462 11.815385 41.353846 0L866.461538 827.076923c11.815385-11.815385 11.815385-29.538462 0-41.353846L610.461538 527.753846c-7.876923-7.876923-7.876923-19.692308 0-27.569231z"></path>
                  </svg>
                )}
              </li>
            )
          })}
          {props.addAble && (
            <li>
              <svg
                onClick={addTab}
                viewBox="0 0 1024 1024"
                width="14"
                height="14"
              >
                <path d="M590.769231 571.076923h324.923077c15.753846 0 29.538462-13.784615 29.538461-29.538461v-59.076924c0-15.753846-13.784615-29.538462-29.538461-29.538461H590.769231c-11.815385 0-19.692308-7.876923-19.692308-19.692308V108.307692c0-15.753846-13.784615-29.538462-29.538461-29.538461h-59.076924c-15.753846 0-29.538462 13.784615-29.538461 29.538461V433.230769c0 11.815385-7.876923 19.692308-19.692308 19.692308H108.307692c-15.753846 0-29.538462 13.784615-29.538461 29.538461v59.076924c0 15.753846 13.784615 29.538462 29.538461 29.538461H433.230769c11.815385 0 19.692308 7.876923 19.692308 19.692308v324.923077c0 15.753846 13.784615 29.538462 29.538461 29.538461h59.076924c15.753846 0 29.538462-13.784615 29.538461-29.538461V590.769231c0-11.815385 7.876923-19.692308 19.692308-19.692308z"></path>
              </svg>
            </li>
          )}
        </ul>
        {/* 内容 -- tab-item */}
        {slots.default?.()}
        {/* 新增的tab对应的内容 */}
        {tab_data.value
          .filter(tab => tab.type === 'dynamic')
          .map(tab => {
            return (
              tab.id === activeTab.value && (
                <div class="s-tab-item">{tab.content}</div>
              )
            )
          })}
      </div>
    )
  }
})

```

### utils

```ts
export function randomId(len: number): string {
  let outStr = ''
  const tempStr = 'abcdefghijklmnopqrstuvwxyz0123456789'
  for (let i = 0; i < len; i++) {
    outStr += tempStr.charAt(Math.floor(Math.random() * tempStr.length))
  }
  return outStr
}

```

### scss

```scss
.s-tabs {
  display: flex;
  flex-direction: column;

  &-ul {
    list-style: none;
    display: inline-flex;
    margin: 0;
    padding: 0;
    border-bottom: 2px solid #e4e7ed;
    cursor: pointer;

    li {
      margin-left: 32px;
      margin-bottom: -2px;
      color: #303133;
      padding-bottom: 4px;

      svg {
        display: inline-block;
      }

      &:first-child {
        margin-left: 0;
      }

      &.s-tabs-li-active {
        font-weight: 700;
        border-bottom: 2px solid #409eff;
        color: #409eff;

        svg {
          fill: #409eff;
        }
      }

      &:hover {
        color: #409eff;

        svg {
          fill: #409eff;
        }
      }
    }
  }
}

```



### tab-item

#### props

```ts
import { ExtractPropTypes } from 'vue'

export const tabItemProps = {
  id: {
    type: String,
    required: true
  },
  title: {
    type: String,
    required: true
  }
} as const
export type TabItemProps = ExtractPropTypes<typeof tabItemProps>

```



#### code

```tsx
import { defineComponent, inject, Ref } from 'vue'
import { TabDataType } from '../tabs-type'
import { TabItemProps, tabItemProps } from './tab-item-type'

export default defineComponent({
  name: 'GTabItem',
  props: tabItemProps,
  setup(props: TabItemProps, { slots }) {
    // 拿到当前active的tab
    const activeTab = inject('CUR_ACTIVE_TAB') as Ref<string>
    // 把tab_item的信息传给tabs
    const tab_data = inject('TAB_DATA') as Ref<TabDataType>
    tab_data.value.push({
      id: props.id,
      title: props.title
    })
    // 提示id不唯一
    const idSet = inject('SET_FOR_TEST') as Ref<Set<string>>
    idSet.value.add(props.id)
    if (idSet.value.size !== tab_data.value.length) {
      console.warn('tab item id should be unique!')
    }
    return () => (
      <>
        {props.id === activeTab.value && (
          <div class="s-tab-item">{slots.default?.()}</div>
        )}
      </>
    )
  }
})

```



## tree

### 使用

```html
    <div class="bg-slate-400">没有checkbox和lineable和lazy,只有operable</div>
    <GTree :data="data" checkable:false></GTree>

    <div class="bg-slate-400">有checkbox和operable和lazy和dragdrop</div>
    <GTree
      :data="data"
      checkable
      operable
      :dragdrop="{ prev: true, next: true, inner: true }"
      lazy
      @lazy-load="lazyLoadCB"
    ></GTree>


    <div class="bg-slate-400">有checkbox和lineable无lazy</div>
    <!-- 在拖拽移动node的时候，check的改变没有做相应变化，所以一般不让check和dragdrop一块开启 -->
    <GTree
      :data="data"
      lineable
      operable
      :dragdrop="{ prev: true, next: true, inner: true }"
    >
      <template #icon="{ node, clickExpandedNode }">
        <span v-if="node.isLeaf" class="devui-tree-node__indent"></span>
        <span
          v-else
          @click="
            event => {
              event.stopPropagation()
              clickExpandedNode(node)
            }
          "
        >
          <svg
            :style="{
              transform: node.expanded ? 'rotate(90deg)' : '',
              display: 'inline-block',
              margin: '0 5px',
              cursor: 'pointer'
            }"
            viewBox="0 0 1024 1024"
            width="12"
            height="12"
          >
            <path
              d="M857.70558 495.009024 397.943314 27.513634c-7.132444-7.251148-18.794042-7.350408-26.048259-0.216941-7.253194 7.132444-7.350408 18.795065-0.216941 26.048259l446.952518 454.470749L365.856525 960.591855c-7.192819 7.192819-7.192819 18.85544 0 26.048259 3.596921 3.596921 8.311293 5.39487 13.024641 5.39487s9.42772-1.798972 13.024641-5.39487L857.596086 520.949836C864.747973 513.797949 864.796068 502.219239 857.70558 495.009024z"
            ></path>
          </svg>
        </span>
      </template>
      <template #content="node">
        <svg
          v-if="node.isLeaf"
          id="octicon_file_16"
          style="margin-right: 8px; display: inline-block"
          viewBox="0 0 16 16"
          width="16"
          height="16"
          fill="#57606a"
        >
          <path
            fill-rule="evenodd"
            d="M3.75 1.5a.25.25 0 00-.25.25v11.5c0 .138.112.25.25.25h8.5a.25.25 0 00.25-.25V6H9.75A1.75 1.75 0 018 4.25V1.5H3.75zm5.75.56v2.19c0 .138.112.25.25.25h2.19L9.5 2.06zM2 1.75C2 .784 2.784 0 3.75 0h5.086c.464 0 .909.184 1.237.513l3.414 3.414c.329.328.513.773.513 1.237v8.086A1.75 1.75 0 0112.25 15h-8.5A1.75 1.75 0 012 13.25V1.75z"
          ></path>
        </svg>
        <svg
          v-else
          id="octicon_file-directory-fill_16"
          viewBox="0 0 16 16"
          width="16"
          height="16"
          fill="#54aeff"
          style="display: inline-block; margin-right: 8px"
        >
          <path
            d="M1.75 1A1.75 1.75 0 000 2.75v10.5C0 14.216.784 15 1.75 15h12.5A1.75 1.75 0 0016 13.25v-8.5A1.75 1.75 0 0014.25 3H7.5a.25.25 0 01-.2-.1l-.9-1.2C6.07 1.26 5.55 1 5 1H1.75z"
          ></path>
        </svg>
        {{ node.label }}
        <svg
          v-if="node.isLeaf"
          title="modified"
          viewBox="0 0 16 16"
          width="16"
          height="16"
          fill="#9a6700"
          style="position: absolute; right: 0; margin-right: 8px"
        >
          <path
            fill-rule="evenodd"
            d="M2.75 2.5h10.5a.25.25 0 01.25.25v10.5a.25.25 0 01-.25.25H2.75a.25.25 0 01-.25-.25V2.75a.25.25 0 01.25-.25zM13.25 1H2.75A1.75 1.75 0 001 2.75v10.5c0 .966.784 1.75 1.75 1.75h10.5A1.75 1.75 0 0015 13.25V2.75A1.75 1.75 0 0013.25 1zM8 10a2 2 0 100-4 2 2 0 000 4z"
          ></path>
        </svg>
      </template>
    </GTree> 
```

### constant

```ts
// 子节点左边的tab缩进px
export const NODE_LEFT_INDENT = 24
export const NODE_HEIGHT = 28

export const TREE_TEST_DATA = [
  {
    label: 'vue3',
    id: '1',
    level: 1,
    expanded: false,
    children: [
      {
        label: 'ts',
        id: '5',
        parentId: '1',
        level: 2,
        checked: true
      },
      {
        label: 'nacos',
        id: '10',
        parentId: '1',
        level: 2,
        checked: false
      }
    ]
  },
  {
    label: 'vite',
    id: '2',
    expanded: true,
    level: 1,
    children: [
      {
        label: 'ui',
        id: '3',
        parentId: '2',
        expanded: false,
        level: 2,
        children: [
          {
            label: 'cli--1',
            id: '4',
            parentId: '3',
            level: 3,
            children: [
              {
                label: 'inner-1',
                id: '111',
                parentId: '4',
                level: 4,
                isLeaf: true
              },
              {
                label: 'inner-2',
                id: '222',
                parentId: '4',
                level: 4,
                isLeaf: true
              },
              {
                label: 'inner-3',
                id: '333',
                parentId: '4',
                level: 4,
                isLeaf: true
              }
            ]
          },
          {
            label: 'cli--2',
            id: '14',
            parentId: '3',
            isLeaf: true,
            level: 3
          }
        ]
      },
      {
        label: 'java',
        id: '7',
        parentId: '2',
        expanded: true,
        level: 2,
        children: [
          {
            label: 'spring',
            id: '8',
            parentId: '7',
            isLeaf: true,
            level: 3
          }
        ]
      }
    ]
  },
  {
    label: 'tsnd',
    id: '6',
    level: 1
  }
]

```



### hooks

#### type

```ts
import { ComputedRef, Ref, SetupContext } from 'vue'
import { IFlatTreeNode, ITreeNode } from '../../tree-type'

export type UseTreeCoreType = {
  getChildNodes: (node: IFlatTreeNode, recursive?: boolean) => IFlatTreeNode[]
  getTreeNodeIndex: (node: IFlatTreeNode) => number
  getExpandedNodeList: ComputedRef<IFlatTreeNode[]>
  getNode: (node: IFlatTreeNode) => IFlatTreeNode | undefined
  getParentNode: (node: IFlatTreeNode) => IFlatTreeNode | undefined
}

export type UseExpandType = {
  clickExpandedNode: (node: IFlatTreeNode) => void
}

export type UseCheckType = {
  checkTreeNode: (node: IFlatTreeNode) => void
}

export type UseOperationType = {
  appendTreeNode: (parent: IFlatTreeNode, node: IFlatTreeNode) => void
  removeTreeNode: (node: IFlatTreeNode) => void
}

export type UseLazyLoadType = {
  lazyLoadNode: (node: IFlatTreeNode) => void
}
export type LazyNodeResType = {
  parentNode: IFlatTreeNode
  childNodes: ITreeNode[]
}
// 拖拽
export type DragDropType = boolean | DropType
export interface DropType {
  prev?: boolean
  next?: boolean
  inner?: boolean
}
export type UseDraggable = {
  onDragStart: (event: DragEvent, node: IFlatTreeNode) => void
  // 在node上面移动时: 决定操作类型（确定放在目标drop节点的prev/next/inner）
  onDragOver: (event: DragEvent) => void
  onDragLeave: (event: DragEvent) => void
  onDragEnd: (event: DragEvent) => void
  onDrop: (event: DragEvent, targetNode: IFlatTreeNode) => void
}
export type DragState = {
  dropType?: keyof Required<DropType>
  // 元素节点
  draggingHtmlNode?: HTMLElement | null
  // 数据节点
  draggingTreeNode?: IFlatTreeNode | null
}

export type TreeHooksType = {
  flatTreeData: Ref<IFlatTreeNode[]>
  context: SetupContext
} & UseTreeCoreType &
  UseExpandType &
  UseCheckType &
  UseOperationType &
  UseLazyLoadType &
  UseDraggable

```



#### use-check

```ts
import { Ref } from 'vue'
import { IFlatTreeNode } from '../tree-type'
import { UseCheckType, UseTreeCoreType } from './type/use-tree-type'

export function useCheck(
  flatTreeData: Ref<IFlatTreeNode[]>,
  { getChildNodes }: UseTreeCoreType
): UseCheckType {
  // 选中复选框后的，父到子的联动，子到父的联动
  const checkTreeNode = (node: IFlatTreeNode) => {
    // 初始化node的checked属性,可能为undefined,初次bug
    node.checked = !node.checked
    // 父到子
    getChildNodes(node, true).forEach(child => {
      child.checked = node.checked
    })
    // 子到父
    // 获取父节点
    const parentNode: IFlatTreeNode = flatTreeData.value.find(
      item => item.id === node.parentId
    ) as IFlatTreeNode
    if (!parentNode) {
      return
    }
    // 有父节点，获取兄弟节点
    const siblingNodes = getChildNodes(parentNode, false)
    const sign = siblingNodes.every(item => item.checked)
    if (sign) {
      // 选中父节点复选框
      parentNode.checked = true
      // 父节点节点 再往上有父节点
      upwardDealSilbingNodes(parentNode, true)
    } else {
      // 取消父节点复选框
      parentNode.checked = false
      // 父节点节点 再往上有父节点
      upwardDealSilbingNodes(parentNode, false)
    }
  }
  function upwardDealSilbingNodes(node: IFlatTreeNode, val: boolean) {
    if (node.parentId) {
      const grandparentNode: IFlatTreeNode = flatTreeData.value.find(
        item => item.id === node.parentId
      ) as IFlatTreeNode
      if (!val) {
        // 取消掉所有上层父级就行
        grandparentNode.checked = false
        upwardDealSilbingNodes(grandparentNode, false)
      } else {
        // 需要拿到父辈node节点的兄弟节点，判断祖先节点是否选中
        const siblingNodes = getChildNodes(grandparentNode, false)
        const sign = siblingNodes.every(item => item.checked)
        if (sign) {
          grandparentNode.checked = true
          upwardDealSilbingNodes(grandparentNode, true)
        } else {
          grandparentNode.checked = false
          upwardDealSilbingNodes(grandparentNode, false)
        }
      }
    }
  }
  return {
    checkTreeNode
  }
}

```



#### use-dragdrop

```ts
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { computed, reactive, Ref } from 'vue'
import { IFlatTreeNode } from '../tree-type'
import {
  DragDropType,
  DragState,
  DropType,
  UseDraggable,
  UseTreeCoreType
} from './type/use-tree-type'

const DropTypeMap = {
  prev: 's-tree-node--prev',
  next: 's-tree-node--next',
  inner: 's-tree-node--inner'
}

export function useDragDrop(
  flatTreeData: Ref<IFlatTreeNode[]>,
  { getChildNodes, getParentNode }: UseTreeCoreType,
  dragdrop: DragDropType
): UseDraggable {
  const dragState = reactive<DragState>({
    dropType: undefined,
    draggingHtmlNode: null,
    draggingTreeNode: null
  })
  const resetDragState = () => {
    dragState.dropType = undefined
    dragState.draggingHtmlNode = null
    dragState.draggingTreeNode = null
  }
  const treeIdMapValue = computed<Record<string | number, IFlatTreeNode>>(
    () => {
      return flatTreeData.value.reduce(
        (acc, cur) => ({
          ...acc,
          [cur.id!]: cur
        }),
        {}
      )
    }
  )

  const removeDraggingStyle = (target: HTMLElement | null) => {
    target?.classList.remove(...Object.values(DropTypeMap))
  }

  const IsChildParent = (
    childNodeId: number | string,
    parentNodeId: number | string
  ): boolean => {
    const realParentId = treeIdMapValue.value[childNodeId]?.parentId
    if (realParentId === parentNodeId) {
      return true
    } else if (realParentId !== undefined) {
      return IsChildParent(realParentId, parentNodeId)
    } else {
      return false
    }
  }

  // 拖拽起始
  const onDragStart = (event: DragEvent, node: IFlatTreeNode): void => {
    event.stopPropagation()
    dragState.draggingHtmlNode = event.target as HTMLElement | null
    dragState.draggingTreeNode = node
    // 将正在拖拽的数据节点id存入dataTransfer，未来需要在drop的时候取出来
    event.dataTransfer?.setData('dragNodeId', node.id!)
  }

  const onDragOver = (event: DragEvent): void => {
    event.preventDefault()
    event.stopPropagation()
    if (!dragState.draggingHtmlNode) {
      return
    }

    if (dragdrop) {
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'move'
      }

      if (!flatTreeData) {
        return
      }
      let curDropType: DropType = {}
      if (typeof dragdrop === 'object') {
        curDropType = dragdrop
      } else if (dragdrop === true) {
        curDropType = { inner: true }
      }
      const { prev, next, inner } = curDropType

      let innerDropType: DragState['dropType']

      const prevPercent = prev ? (inner ? 0.25 : next ? 0.45 : 1) : -1
      const nextPercent = next ? (inner ? 0.75 : prev ? 0.55 : 0) : 1
      const currentTarget = event.currentTarget as HTMLElement | null
      const targetPosition = currentTarget?.getBoundingClientRect()
      const distance = event.clientY - (targetPosition?.top || 0)

      if (distance < (targetPosition?.height || 0) * prevPercent) {
        innerDropType = 'prev'
      } else if (distance > (targetPosition?.height || 0) * nextPercent) {
        innerDropType = 'next'
      } else if (inner) {
        innerDropType = 'inner'
      } else {
        innerDropType = undefined
      }
      if (innerDropType) {
        const classList = currentTarget?.classList
        if (classList) {
          if (!classList.contains(DropTypeMap[innerDropType])) {
            removeDraggingStyle(currentTarget)
            classList.add(DropTypeMap[innerDropType])
          }
        }
      } else {
        removeDraggingStyle(currentTarget)
      }
      dragState.dropType = innerDropType
    }
  }

  const onDragLeave = (event: DragEvent): void => {
    event.stopPropagation()
    if (!dragState.draggingHtmlNode) {
      return
    }
    removeDraggingStyle(event.currentTarget as HTMLElement | null)
  }

  // 释放事件回调
  const onDrop = (event: DragEvent, targetNode: IFlatTreeNode): void => {
    event.preventDefault()
    event.stopPropagation()
    removeDraggingStyle(event.currentTarget as HTMLElement | null)
    if (!dragState.draggingHtmlNode || !dragdrop) return

    // 获取正在被拖拽的树节点id
    const dragNodeId = event.dataTransfer?.getData('dragNodeId')
    if (dragNodeId) {
      // 判断释放节点 是否是 被拖拽的节点的子节点（不合理）
      const isParent = IsChildParent(targetNode.id!, dragNodeId)
      // 如果拖拽和释放是同一节点或者是父子关系则跳出
      if (dragNodeId === targetNode.id || isParent) {
        return
      }
      // 判断当前释放类型：prev、next或inner
      if (dragState.dropType) {
        handleDrop(dragNodeId, targetNode)
      }

      resetDragState()
    }
  }

  // 释放之后的节点操作
  function handleDrop(dragNodeId: string, dropNode: IFlatTreeNode) {
    // 获取正在拖拽的节点
    const dragNode = flatTreeData.value.find(item => item.id === dragNodeId)

    if (dragNode) {
      // 备份一个节点
      let cloneDragNode: IFlatTreeNode
      // 获取拖拽节点子节点
      const dragNodeChildren = getChildNodes(dragNode)
      // 获取拖拽节点的父节点
      const dragNodeParent = getParentNode(dragNode)

      // 如果是嵌套释放情况
      if (dragState.dropType === 'inner') {
        cloneDragNode = {
          ...dragNode,
          parentId: dropNode.id,
          level: dropNode.level + 1
        }
        // 插入克隆节点
        const dropNodeIndex = flatTreeData.value.indexOf(dropNode)
        flatTreeData.value.splice(dropNodeIndex + 1, 0, cloneDragNode)
        // 需要改进，如果改为false，会对懒加载产生影响
        dropNode.isLeaf = undefined
        // 删除旧拖拽节点
        const dragNodeIndex = flatTreeData.value.indexOf(dragNode)
        flatTreeData.value.splice(dragNodeIndex, 1)
      } else if (dragState.dropType === 'next') {
        cloneDragNode = {
          ...dragNode,
          parentId: dropNode.parentId,
          level: dropNode.level
        }
        // drop节点可能有自己的孩子，这时候
        // drag节点就要放到（扁平数组中的）drop节点的最后一个孩子的index+1
        const dropNodeIndex = flatTreeData.value.indexOf(dropNode)
        const dropNodeChildrenLength = getChildNodes(dropNode, true).length
        flatTreeData.value.splice(
          dropNodeIndex + dropNodeChildrenLength + 1,
          0,
          cloneDragNode
        )
        const dragNodeIndex = flatTreeData.value.indexOf(dragNode)
        flatTreeData.value.splice(dragNodeIndex, 1)
      } else if (dragState.dropType === 'prev') {
        cloneDragNode = {
          ...dragNode,
          parentId: dropNode.parentId,
          level: dropNode.level
        }
        const dropNodeIndex = flatTreeData.value.indexOf(dropNode)
        flatTreeData.value.splice(dropNodeIndex, 0, cloneDragNode)
        const dragNodeIndex = flatTreeData.value.indexOf(dragNode)
        flatTreeData.value.splice(dragNodeIndex, 1)
      }

      // 如果拖拽的是有子节点的节点，所有子节点也应该以inner方式被移动
      dragState.dropType = 'inner'
      dragNodeChildren.forEach(child => handleDrop(child.id!, cloneDragNode))

      // 拖拽结束，可能被往外拖拽走的节点，是父节点唯一节点，处理父节点isLeaf状态
      if (dragNodeParent) {
        if (getChildNodes(dragNodeParent).length === 0) {
          dragNodeParent.isLeaf = true
        }
      }
    }
  }
  const onDragEnd = (event: DragEvent) => {
    event.preventDefault()
    event.stopPropagation()
    resetDragState()
  }
  return {
    onDragStart,
    onDragOver,
    onDragLeave,
    onDragEnd,
    onDrop
  }
}

```



#### use-expand

```ts
import { Ref, SetupContext } from 'vue'
import { IFlatTreeNode } from '../tree-type'
import {
  UseExpandType,
  UseLazyLoadType,
  UseTreeCoreType
} from './type/use-tree-type'

export function useExpand(
  flatTreeData: Ref<IFlatTreeNode[]>,
  core: UseTreeCoreType,
  context: SetupContext,
  lazyLoad: UseLazyLoadType
): UseExpandType {
  const { lazyLoadNode } = lazyLoad
  // 点击展开三角-触发事件
  const clickExpandedNode = (node: IFlatTreeNode) => {
    const cur = flatTreeData.value.find(item => item.id === node.id)
    if (cur) {
      cur.expanded = !cur.expanded
      // 当前是展开的，判断是否要懒加载cur下的所有子节点
      if (cur.expanded) {
        lazyLoadNode(cur)
      }
    }
  }

  return {
    clickExpandedNode
  }
}

```



#### use-lazy-load

```ts
import { ref, Ref, SetupContext } from 'vue'
import { IFlatTreeNode } from '../tree-type'
import {
  LazyNodeResType,
  UseLazyLoadType,
  UseTreeCoreType
} from './type/use-tree-type'
import { generateFlatTree } from '../utils'
export function useLazyLoad(
  flatTreeData: Ref<IFlatTreeNode[]>,
  { getNode, getTreeNodeIndex, getChildNodes }: UseTreeCoreType,
  { emit }: SetupContext
): UseLazyLoadType {
  // 设置子节点的 父节点
  const setParent = (
    parentNode: IFlatTreeNode,
    childNodesList: Ref<IFlatTreeNode[]>
  ) => {
    childNodesList.value.forEach(child => {
      // 相差一层且parentId没有设置
      if (child.level - 1 === parentNode.level && !child.parentId) {
        child.parentId = parentNode.id
      }
    })
  }
  // 将异步获取的子节点加入父节点后面
  const insertChildren = (
    parentNode: IFlatTreeNode,
    childNodesList: Ref<IFlatTreeNode[]>
  ) => {
    const parentIndex = getTreeNodeIndex(parentNode)
    if (parentIndex) {
      flatTreeData.value.splice(parentIndex + 1, 0, ...childNodesList.value)
    }
  }
  // 在异步获取完子节点后，调用的回调函数
  const dealLazyChildNodeCB = (result: LazyNodeResType) => {
    // 获取父节点
    const node = getNode(result.parentNode)
    if (node) {
      // 结束加载状态
      node.loading = false
      // 扁平化处理
      const flatChildNodesList = ref<IFlatTreeNode[]>(
        generateFlatTree(result.childNodes, node.level)
      )
      // 处理子节点和父节点之间的关系
      setParent(node, flatChildNodesList)
      insertChildren(node, flatChildNodesList)
      // 更新父节点孩子数量(false最近的一代)
      const newChildNodesArr = getChildNodes(node, false)
      node.childNodeCount = newChildNodesArr.length
    }
  }

  // 接收一个节点，派发事件，外部调用异步方法获取数据，传入回调函数
  const lazyLoadNode = (node: IFlatTreeNode) => {
    const innerNode = getNode(node)
    // 判断是否需要懒加载节点
    if (innerNode?.isLeaf === false && !innerNode.childNodeCount) {
      // 初始childNodeCount为undefined，一次回调后设置了值，后续就不跑这个if
      // 需要懒加载
      innerNode.loading = true
      // 派发事件,让外面加载数据
      emit('lazy-load', node, dealLazyChildNodeCB)
    }
  }

  return {
    lazyLoadNode
  }
}

```



#### use-operation

```ts
import { ref, Ref } from 'vue'
import { IFlatTreeNode } from '../tree-type'
import { UseOperationType, UseTreeCoreType } from './type/use-tree-type'
import { randomId } from '../utils'

export function useOperation(
  flatTreeData: Ref<IFlatTreeNode[]>,
  { getChildNodes, getTreeNodeIndex }: UseTreeCoreType
): UseOperationType {
  // 添加孩子节点到父元素children[]末尾
  const appendTreeNode = (parent: IFlatTreeNode, node: IFlatTreeNode) => {
    // parent有孩子,获取最后一个子节点
    const childNodeList = getChildNodes(parent, false)
    const lastChild = childNodeList[childNodeList.length - 1]
    // 找到要插入的位置index: 默认为parent后一位
    let insertIndex = getTreeNodeIndex(parent) + 1
    if (lastChild) {
      insertIndex = getTreeNodeIndex(lastChild) + 1
    } else {
      // parent是叶子节点 (insertIndex保持默认)
    }
    // 处理节点
    parent.expanded = true
    parent.isLeaf = false
    const newChild = ref({
      ...node,
      level: parent.level + 1,
      parentId: parent.id,
      isLeaf: true,
      id: randomId(10)
    })
    // 插入节点
    flatTreeData.value.splice(insertIndex, 0, newChild.value)
  }

  // 删除节点以及它的所有孩子节点
  const removeTreeNode = (node: IFlatTreeNode) => {
    const childNodeIdList = getChildNodes(node, true).map(child => child.id)
    if (childNodeIdList.length === 0) {
      // 没有孩子
      flatTreeData.value = flatTreeData.value.filter(
        item => item.id !== node.id
      )
    } else {
      // 有孩子
      flatTreeData.value = flatTreeData.value.filter(
        item => item.id !== node.id && !childNodeIdList.includes(item.id)
      )
    }
  }
  return {
    appendTreeNode,
    removeTreeNode
  }
}

```



#### use-tree-core

```ts
import { computed, Ref } from 'vue'
import { IFlatTreeNode } from '../tree-type'
import { UseTreeCoreType } from './type/use-tree-type'

export function useTreeCore(
  flatTreeData: Ref<IFlatTreeNode[]>
): UseTreeCoreType {
  // 获取扁平数组内，node结点的所有子元素，作为数组返回
  // 参数recursive: true 所有后代. false: 第一代直接后代
  const getChildNodes: (
    node: IFlatTreeNode,
    recursive?: boolean
  ) => IFlatTreeNode[] = (node: IFlatTreeNode, recursive = true) => {
    const res: IFlatTreeNode[] = []
    const startIndex = flatTreeData.value.findIndex(item => item.id === node.id)
    for (
      let i = startIndex + 1;
      i < flatTreeData.value.length && node.level < flatTreeData.value[i].level;
      i++
    ) {
      if (recursive) {
        // 递归，所有后代子结点
        res.push(flatTreeData.value[i])
      } else if (node.level + 1 === flatTreeData.value[i].level) {
        // 第一直接代子结点
        res.push(flatTreeData.value[i])
      }
    }
    return res
  }
  // 在扁平化后的数组中找到node的index
  function getTreeNodeIndex(node: IFlatTreeNode) {
    if (!node) return -1
    return flatTreeData.value.findIndex(item => item.id === node.id)
  }
  // 获取展开的结点列表 (真正显示，渲染的所有node的列表)
  const getExpandedNodeList = computed(() => {
    let excludeNodes: IFlatTreeNode[] = []
    const resultNodes: IFlatTreeNode[] = []
    for (const node of flatTreeData.value) {
      // 此次node在excludeNodes中，跳过此次循环
      if (excludeNodes.includes(node)) {
        continue
      }
      // 没展开，排除子结点
      if (node.expanded !== true) {
        excludeNodes = getChildNodes(node, true)
      }
      resultNodes.push(node)
    }
    return resultNodes
  })
  const getNode = (node: IFlatTreeNode) => {
    if (!node) return undefined
    return flatTreeData.value.find(item => item.id === node.id)
  }
  const getParentNode = (node: IFlatTreeNode) => {
    if (!node) return undefined
    return flatTreeData.value.find(item => item.id === node.parentId)
  }
  return {
    getChildNodes,
    getTreeNodeIndex,
    getExpandedNodeList,
    getNode,
    getParentNode
  }
}

```



#### use-tree

```ts
import { Ref, ref, SetupContext, unref } from 'vue'
import { ITreeNode, TreeProps } from '../tree-type'
import { generateFlatTree } from '../utils'
import { TreeHooksType } from './type/use-tree-type'
import { useCheck } from './use-check'
import { useDragDrop } from './use-dragdrop'
import { useExpand } from './use-expand'
import { useLazyLoad } from './use-lazy-load'
import { useOperation } from './use-operation'
import { useTreeCore } from './use-tree-core'

export function useTree(
  node: Ref<ITreeNode[]> | ITreeNode[],
  props: TreeProps,
  context: SetupContext
): TreeHooksType {
  // 做一个扁平化处理
  const flatTreeData = ref(generateFlatTree(unref(node)))
  const core = useTreeCore(flatTreeData)
  const hooksList = [useCheck, useExpand, useOperation]
  const lazyLoad = useLazyLoad(flatTreeData, core, context)
  const dragDropPlugin = useDragDrop(flatTreeData, core, props.dragdrop)
  const hooksFunction = hooksList.reduce((resObj, curHook) => {
    return { ...resObj, ...curHook(flatTreeData, core, context, lazyLoad) }
  }, {})
  return {
    ...hooksFunction,
    ...core,
    ...dragDropPlugin,
    flatTreeData
  } as TreeHooksType
}

```



### props

```ts
import { ExtractPropTypes, PropType } from 'vue'
import { DragDropType } from './hooks/type/use-tree-type'

export const treeProps = {
  data: {
    type: Object as PropType<Array<ITreeNode>>,
    required: true
  },
  // 多选框
  checkable: {
    type: Boolean,
    default: false
  },
  // 左侧线
  lineable: {
    type: Boolean,
    default: false
  },
  // 添加删除节点
  operable: {
    type: Boolean,
    default: false
  },
  // 懒加载
  lazy: {
    type: Boolean,
    default: false
  },
  // 拖拽
  dragdrop: {
    // 可能丢到节点里面，上面，下面
    type: [Boolean, Object] as PropType<DragDropType>,
    default: false
  },
  // 设置了高度，代表要开启虚拟滚动
  height: {
    type: Number
  },
  itemHeight: {
    type: Number,
    default: 24
  }
} as const
export type TreeProps = ExtractPropTypes<typeof treeProps>

export interface ITreeNode {
  label: string
  id?: string
  children?: ITreeNode[]

  selected?: boolean // 选中
  checked?: boolean // 勾选
  expanded?: boolean // 展开
  loading?: boolean // 节点是否显示加载中
  childNodeCount?: number // 该节点的数量

  disableSelect?: boolean
  disableCheck?: boolean
  disableExpand?: boolean
}
// 单纯用ITreeNode可以达到效果，但是可能嵌套过多
// 需要递归操作，且很难做虚拟滚动,所以引入IFlatTreeNode
// 不同层级子元素要缩进，用level可以作为缩进的倍数
export interface IFlatTreeNode extends ITreeNode {
  parentId?: string // 父级id
  level: number // 结点层级
  isLeaf?: boolean // 是否为叶子结点
}

```



### code

```tsx
import { defineComponent, provide, SetupContext, toRefs } from 'vue'

import { useTree } from './hooks/use-tree'
import { IFlatTreeNode, TreeProps, treeProps } from './tree-type'
import GTreeNode from './components/tree-node'
import GTreeSvg from './components/node-slots-svg'
import '../style/tree.scss'
import { VirtualList } from '../../virtual-list/index'

export default defineComponent({
  name: 'GTree',
  props: treeProps,
  emits: ['lazy-load'],
  setup(props: TreeProps, context) {
    // checkable、lineable、operable 已经{...props}传入
    const { data, height, itemHeight } = toRefs(props)
    const { slots } = context
    const {
      clickExpandedNode,
      getExpandedNodeList,
      checkTreeNode,
      getChildNodes,
      appendTreeNode,
      removeTreeNode,
      onDragStart,
      onDragOver,
      onDragLeave,
      onDragEnd,
      onDrop
    } = useTree(data, props, context as SetupContext)
    provide('TREE_HOOKS', {
      clickExpandedNode,
      checkTreeNode,
      getChildNodes,
      appendTreeNode,
      removeTreeNode,
      onDragStart,
      onDragOver,
      onDragLeave,
      onDragEnd,
      onDrop
    })
    return () => {
      const TreeNode = (node: IFlatTreeNode) => (
        <GTreeNode {...props} node={node}>
          {{
            content: () => (slots.content ? slots.content(node) : node.label),
            icon: () =>
              slots.icon ? (
                slots.icon({ node, clickExpandedNode })
              ) : (
                <GTreeSvg
                  expanded={!!node.expanded}
                  onClick={() => clickExpandedNode(node)}
                ></GTreeSvg>
              ),
            loading: () =>
              slots.loading ? (
                slots.loading({ node })
              ) : (
                <span class="ml-1">loading...</span>
              )
          }}
        </GTreeNode>
      )
      return (
        <div class="s-tree">
          {height?.value ? (
            // 虚拟列表
            <div style={{ height: `${height.value}px` }}>
              <VirtualList
                data={getExpandedNodeList?.value}
                itemHeight={itemHeight.value}
              >
                {{
                  default: ({ item: node }: { item: IFlatTreeNode }) =>
                    TreeNode(node)
                }}
              </VirtualList>
            </div>
          ) : (
            getExpandedNodeList?.value.map((node: IFlatTreeNode) => {
              return TreeNode(node)
            })
          )}
        </div>
      )
    }
  }
})

```

### utils

```ts
import { IFlatTreeNode, ITreeNode } from './tree-type'
export function generateFlatTree(
  tree: ITreeNode[],
  level = 0,
  parentNode = {} as IFlatTreeNode
): IFlatTreeNode[] {
  level++
  const resArr: IFlatTreeNode[] = tree?.reduce((pre, cur) => {
    const curNode = { ...cur } as IFlatTreeNode
    // 初始化状态
    curNode.selected = curNode.selected ?? false
    curNode.checked = curNode.checked ?? false
    curNode.expanded = curNode.expanded ?? false
    // 设置curNode的level
    curNode.level = level
    // 设置parentId
    if (level > 1 && parentNode) {
      curNode.parentId = parentNode.id
    }
    // cur 是否存在children, 设置
    if (curNode.children) {
      curNode.isLeaf = false
      // 需要删除父节点children数组属性
      const children = generateFlatTree(curNode.children, level, curNode)
      delete curNode.children
      // 把cur结点和所有的子结点 拼接在一起
      return pre.concat(curNode, children)
    } else {
      // 叶子结点
      // curNode.isLeaf = true
      // 可能懒加载要把isLeaf提前的，故意的设置为true，但是不代表curNode就一定是叶子节点
      if (curNode.isLeaf === undefined) {
        curNode.isLeaf = true
      }
      return pre.concat(curNode)
    }
  }, [] as IFlatTreeNode[])
  // resArr[0].expanded = true
  return resArr
}

export function randomId(len: number): string {
  let outStr = ''
  const tempStr = 'abcdefghijklmnopqrstuvwxyz0123456789'
  for (let i = 0; i < len; i++) {
    outStr += tempStr.charAt(Math.floor(Math.random() * tempStr.length))
  }
  return outStr
}

```

### scss

```scss
.s-tree {
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
  .s-tree-node {
    &--content {
      border: 1px solid transparent;
    }
    &--prev {
      border: 1px solid red;
      opacity: 0.4;
    }
    &--inner {
      border: 1px solid green;
      opacity: 0.4;
    }
    &--next {
      border: 1px solid blue;
      opacity: 0.4;
    }
  }
}

```



### tree-node

#### props

```ts
import { ExtractPropTypes, PropType } from 'vue'
import { IFlatTreeNode, treeProps } from '../../tree-type'

export const treeNodeProps = {
  ...treeProps,
  node: {
    type: Object as PropType<IFlatTreeNode>,
    required: true
  }
} as const
export type TreeNodeProps = ExtractPropTypes<typeof treeNodeProps>

export type TreeInjectType = {
  clickExpandedNode: (node: IFlatTreeNode) => void
  getChildNodes: (node: IFlatTreeNode, recursive?: boolean) => IFlatTreeNode[]
  checkTreeNode: (node: IFlatTreeNode) => void
  appendTreeNode: (parent: IFlatTreeNode, node: IFlatTreeNode) => void
  removeTreeNode: (node: IFlatTreeNode) => void
  onDragStart: (event: DragEvent, node: IFlatTreeNode) => void
  onDragOver: (event: DragEvent) => void
  onDragLeave: (event: DragEvent) => void
  onDragEnd: (event: DragEvent) => void
  onDrop: (event: DragEvent, targetNode: IFlatTreeNode) => void
}

```



#### code

```tsx
import { defineComponent, inject, toRefs, unref, ref } from 'vue'
import { NODE_LEFT_INDENT, NODE_HEIGHT } from '../constant'
import { IFlatTreeNode } from '../tree-type'
import {
  TreeInjectType,
  TreeNodeProps,
  treeNodeProps
} from './type/tree-node-type'

export default defineComponent({
  name: 'GTreeNode',
  props: treeNodeProps,
  setup(props: TreeNodeProps, { slots }) {
    const { lineable, checkable, node, operable, lazy, dragdrop } =
      toRefs(props)
    /*const { clickExpandedNode, checkTreeNode, getChildNodes } =
      inject<TreeInjectType>('TREE_HOOKS') as any 
      or
      const { clickExpandedNode, checkTreeNode, getChildNodes } =
      inject<TreeInjectType>('TREE_HOOKS', {}, {}, {})
      or
      const { clickExpandedNode, checkTreeNode, getChildNodes } =
      inject('TREE_HOOKS') as TreeInjectType
    */
    const {
      checkTreeNode,
      getChildNodes,
      appendTreeNode,
      removeTreeNode,
      onDragStart,
      onDragOver,
      onDragLeave,
      onDragEnd,
      onDrop
    } = inject('TREE_HOOKS') as TreeInjectType
    const isShow = ref(false)
    const mouseOperation = () => {
      if (isShow.value) {
        isShow.value = false
      } else {
        isShow.value = true
      }
    }
    // 构造drag属性对象
    let dragDropProps = {}
    // 坑：事件绑定 onDragend/onDragleave....而不是 onDragEnd/onDragLeave....
    if (dragdrop.value) {
      dragDropProps = {
        draggable: true,
        onDragend: (event: DragEvent) => onDragEnd(event),
        onDragleave: (event: DragEvent) => onDragLeave(event),
        onDragover: (event: DragEvent) => onDragOver(event),
        onDragstart: (event: DragEvent) => onDragStart(event, node.value),
        onDrop: (event: DragEvent) => onDrop(event, node.value)
      }
    }
    return () => {
      // eslint-disable-next-line prefer-const
      let { level, expanded, isLeaf, checked } = unref(node)
      return (
        <div
          class="s-tree-node hover:bg-slate-300 relative leading-8"
          style={{
            paddingLeft: `${NODE_LEFT_INDENT * (level - 1)}px`
          }}
          onMouseenter={mouseOperation}
          onMouseleave={mouseOperation}
        >
          {/* 连接线 */}
          {!isLeaf && expanded && lineable.value && (
            <span
              class="s-tree-node--line absolute w-px bg-gray-400"
              style={{
                height: `${
                  NODE_HEIGHT * getChildNodes(node.value, false).length
                }px`,
                top: `${NODE_HEIGHT}px`,
                left: `${NODE_LEFT_INDENT * (level - 1) + 9}px`
              }}
            ></span>
          )}
          {/* 容器，节点内容 */}
          <div class="s-tree-node--content" {...dragDropProps}>
            {/* 折叠图标 */}
            {isLeaf ? (
              <span style={{ display: 'inline-block', width: '25px' }}></span>
            ) : (
              slots.icon?.()
            )}
            {/* 复选框 */}
            {checkable.value && (
              <input
                type="checkbox"
                v-model={checked}
                style={{ marginRight: '8px' }}
                onClick={() => checkTreeNode(node.value)}
              ></input>
            )}
            {/* 标签内容*/}
            {slots.content?.()}

            {/* 节点增删操作 */}
            {operable.value && isShow.value && (
              <span class="inline-flex ml-1">
                <svg
                  onClick={() => {
                    appendTreeNode(node.value, {
                      label: '新节点'
                    } as IFlatTreeNode)
                  }}
                  viewBox="0 0 1024 1024"
                  width="14"
                  height="14"
                  class="cursor-pointer"
                >
                  <path d="M590.769231 571.076923h324.923077c15.753846 0 29.538462-13.784615 29.538461-29.538461v-59.076924c0-15.753846-13.784615-29.538462-29.538461-29.538461H590.769231c-11.815385 0-19.692308-7.876923-19.692308-19.692308V108.307692c0-15.753846-13.784615-29.538462-29.538461-29.538461h-59.076924c-15.753846 0-29.538462 13.784615-29.538461 29.538461V433.230769c0 11.815385-7.876923 19.692308-19.692308 19.692308H108.307692c-15.753846 0-29.538462 13.784615-29.538461 29.538461v59.076924c0 15.753846 13.784615 29.538462 29.538461 29.538461H433.230769c11.815385 0 19.692308 7.876923 19.692308 19.692308v324.923077c0 15.753846 13.784615 29.538462 29.538461 29.538461h59.076924c15.753846 0 29.538462-13.784615 29.538461-29.538461V590.769231c0-11.815385 7.876923-19.692308 19.692308-19.692308z"></path>
                </svg>
                <svg
                  onClick={() => {
                    removeTreeNode(node.value)
                  }}
                  viewBox="0 0 1024 1024"
                  width="14"
                  height="14"
                  class="cursor-pointer ml-1"
                >
                  <path d="M610.461538 500.184615l256-257.96923c11.815385-11.815385 11.815385-29.538462 0-41.353847l-39.384615-41.353846c-11.815385-11.815385-29.538462-11.815385-41.353846 0L527.753846 417.476923c-7.876923 7.876923-19.692308 7.876923-27.569231 0L242.215385 157.538462c-11.815385-11.815385-29.538462-11.815385-41.353847 0l-41.353846 41.353846c-11.815385 11.815385-11.815385 29.538462 0 41.353846l257.969231 257.969231c7.876923 7.876923 7.876923 19.692308 0 27.56923L157.538462 785.723077c-11.815385 11.815385-11.815385 29.538462 0 41.353846l41.353846 41.353846c11.815385 11.815385 29.538462 11.815385 41.353846 0L498.215385 610.461538c7.876923-7.876923 19.692308-7.876923 27.56923 0l257.969231 257.969231c11.815385 11.815385 29.538462 11.815385 41.353846 0L866.461538 827.076923c11.815385-11.815385 11.815385-29.538462 0-41.353846L610.461538 527.753846c-7.876923-7.876923-7.876923-19.692308 0-27.569231z"></path>
                </svg>
              </span>
            )}
            {/* loading状态显示 */}
            {lazy.value && node.value.loading && slots.loading?.()}
          </div>
        </div>
      )
    }
  }
})

```

#### node-slots-svg

```tsx
import { SetupContext } from 'vue'

export default (props: { expanded: boolean }, { emit }: SetupContext) => (
  <svg
    onClick={() => emit('onClick')}
    style={{
      width: '18px',
      height: '18px',
      verticalAlign: 'text-top',
      display: 'inline-block',
      transform: props.expanded ? 'rotate(90deg)' : ''
    }}
    viewBox="0 0 1024 1024"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path fill="currentColor" d="M384 192v640l384-320.064z"></path>
  </svg>
)
```



## virtual-list

### 使用

```html
<div class="bg-slate-400">虚拟列表</div>
<GTree :data="mockData" :height="300"></GTree>
<!--
  const mockData = ref([
    ...Array.from({ length: 50 }).map((item, index) => ({
      id: 'node-' + index,
      label: 'node_label-' + index
    }))
  ])
-->
```



### props

```ts
import { ExtractPropTypes } from 'vue'

export const virtualListProps = {
  data: {
    type: Array,
    default: []
  },
  itemHeight: {
    type: Number,
    default: 24
  },
  component: {
    type: String,
    default: 'div'
  }
} as const
export type VirtualListProps = ExtractPropTypes<typeof virtualListProps>

```



### code

```tsx
import { computed, defineComponent, onMounted, ref, toRefs } from 'vue'
import { VirtualListProps, virtualListProps } from './virtual-list-type'
import '../style/virtual-list.scss'

export default defineComponent({
  name: 'GVirtualList',
  props: virtualListProps,
  setup(props: VirtualListProps, { slots }) {
    const { data, itemHeight, component: Component } = toRefs(props)
    // 容器高度
    const containerHeight = ref(0)
    // 起始索引
    const startIndex = ref(0)
    // 容器ref
    const containerRef = ref()
    // 列表在Y轴的偏移量
    const offsetY = ref(0)

    // 可视区列表元素数量
    const visibleCount = computed(() =>
      Math.ceil(containerHeight.value / itemHeight.value)
    )
    // 可视区域的数据
    const visibleData = computed(() => {
      // 防止最后范围过大出bug
      const limitedLen = Math.min(
        startIndex.value + visibleCount.value,
        data.value.length
      )
      return data.value.slice(startIndex.value, limitedLen)
    })

    // 容器高度自适应
    onMounted(() => {
      containerHeight.value = containerRef.value?.clientHeight
    })

    const scrollEvent = (event: UIEvent) => {
      const { scrollTop } = event.target as HTMLElement
      // visibleData会相应的重新计算
      startIndex.value = Math.floor(scrollTop / itemHeight.value)
      // 改变列表元素在y轴的偏移量
      offsetY.value = scrollTop - (scrollTop % itemHeight.value)
    }

    return () => {
      return (
        <Component.value
          id="s-virtual-list-id"
          class="s-virtual-list--container"
          onScroll={scrollEvent}
          ref={containerRef}
        >
          <div
            class="s-virtual-list--blank"
            style={{ height: `${data.value.length * itemHeight.value}px` }}
          ></div>
          <div
            class="s-virtual-list"
            style={{ transform: `translate3d(0,${offsetY.value}px,0)` }}
          >
            {visibleData.value.map((item, index) =>
              slots.default?.({ item, index })
            )}
          </div>
        </Component.value>
      )
    }
  }
})

```

### scss

```scss
.s-virtual-list {
  &--container {
    height: 100%;
    overflow: auto;
    position: relative;
    -webkit-overflow-scrolling: touch;
  }
  &--blank {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    z-index: -1;
  }
}

```













