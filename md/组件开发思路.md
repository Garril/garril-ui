# Garril-UI组件开发思路

<hr/>



## 组件文件目录结构

<hr/>

```css
以button组件为例，其他组件也都差不多
button
	src
		(像form可能有form-item，就在这里开一个components文件夹)
		button.tsx
		button-type.ts
	style
		button-config.scss
		button.scss
		button-base.scss
	test
		button.test.ts
	index.ts
```



## 组件内容案例 ( button )

<hr/>

以button为例子，展示其组件各个文件大致设计

### / src / button.tsx

```tsx
import { defineComponent, toRefs } from 'vue'
import { ButtonProps, buttonProps } from './button-type'

export default defineComponent({
  name: 'GButton',
  props: buttonProps,
  setup(props: ButtonProps, { slots }) {
    const { type, size, disabled, block } = toRefs(props)
    return () => {
      const defaultSlot = slots.default ? slots.default() : '按钮'
      const blockClass = block.value ? 's-btn--block' : ''
      return (
        <button
          disabled={disabled.value}
          class={`s-btn s-btn--${type.value} s-btn--${size.value} ${blockClass}`}
        >
          {defaultSlot}
        </button>
      )
    }
  }
})

```

### / src / button-type.ts

```ts
import { ExtractPropTypes, PropType } from 'vue'

export type IButtonType = 'primary' | 'secondary' | 'text'
export type IButtonSize = 'small' | 'medium' | 'large'

// button中的props定义
export const buttonProps = {
  type: {
    type: String as PropType<IButtonType>,
    default: 'secondary'
  },
  size: {
    type: String as PropType<IButtonSize>,
    default: 'medium'
  },
  disabled: {
    type: Boolean,
    default: false
  },
  block: {
    type: Boolean,
    default: false
  }
}

// 利用值反推出Button属性类型
export type ButtonProps = ExtractPropTypes<typeof buttonProps>
```

### / style / button.scss

```scss
// button.scss
@use './button-config.scss';
@import './button-base.scss';

.s-btn {
  @include button-base;
  // 导入type相关的样式
  @include button-variant(button-config.$type);
  // 导入size相关的样式
  @include button-variant(button-config.$size);
  // 导入hover等伪类
  @include button-variant(button-config.$pseudo, true);
}
```

### / style / button-base.scss

```scss
// button-base.scss
@import '../../style/variable.scss'; // scss变量定义文件 --- 全局style目录下

@mixin button-base {
  // 布局
  @apply inline-flex items-center justify-center;
  // 元素
  @apply border-[1px] border-solid border-transparent
  h-[28px] py-0 px-[20px]
  bg-transparent;
  border-radius: $s-border-radius;

  // 文本属性
  @apply outline-0 leading-normal whitespace-nowrap
    cursor-pointer;

  // 文字样式
  font-size: $s-font-size-md;

  // 其他样式
  transition: background-color $s-animation-duration-slow
      $s-animation-ease-in-out-smooth,
    border-color $s-animation-duration-slow $s-animation-ease-in-out-smooth,
    color $s-animation-duration-slow $s-animation-ease-in-out-smooth;

  // 禁用状态
  &[disabled] {
    @apply cursor-not-allowed;
  }

  &.s-btn--block {
    @apply block w-full;
  }
  &.s-btn--loading {
    // @apply
  }
}

@mixin button-variant($variant, $pseudo: false) {
  @each $key, $value in $variant {
    // 第一层是多态的类型
    &.s-btn--#{$key} {
      @each $item-key, $item-value in $value {
        // 第二层是多态类型下的样式
        @if $pseudo {
          // 如果是伪类就继续第三层
          &:#{$item-key} {
            @each $sub-item-key, $sub-item-value in $item-value {
              // 第三层是伪类的样式
              #{$sub-item-key}: $sub-item-value;
            }
          }
        } @else {
          // 不是伪类就直接设置样式
          #{$item-key}: $item-value;
        }
      }
    }
  }
}
```

### / style / button-config.scss

```scss
// button-config.scss
// 所有不同type按钮自定义样式
@import '../../style/variable.scss';

// 按钮类型的配置
$type: (
  primary: (
    color: $s-light-text,
    background-color: $s-primary
  ),
  secondary: (
    color: $s-text,
    background-color: $s-block,
    border-color: $s-line
  ),
  text: (
    padding: 0,
    color: $s-brand-active
  )
);

// 伪类的配置
$pseudo: (
  primary: (
    hover: (
      background-color: $s-primary-hover
    ),
    focus: (
      background-color: $s-primary-hover
    ),
    active: (
      background-color: $s-primary-active
    ),
    disabled: (
      color: $s-light-text,
      background-color: $s-primary-disabled,
      border: none
    )
  ),
  secondary: (
    hover: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    focus: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    active: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    disabled: (
      color: $s-disabled-text,
      background-color: $s-disabled-bg,
      border: 1px solid $s-disabled-line
    )
  ),
  text: (
    hover: (
      color: $s-brand-active-focus
    ),
    focus: (
      color: $s-brand-active-focus
    ),
    active: (
      color: $s-brand-active-focus
    ),
    disabled: (
      color: $s-disabled-text
    )
  )
);

// 按钮尺寸
$size: (
  small: (
    height: 24px,
    padding: 0 16px,
    font-size: $s-font-size-sm
  ),
  medium: (
    font-size: $s-font-size-md
  ),
  large: (
    height: 32px,
    padding: 0 24px,
    font-size: $s-font-size-lg
  )
);
```

### / test /  button.test.ts

```ts
import { render } from '@testing-library/vue'
import Button from '../src/button'

// base button
test('test base button,without anything passed', () => {
  const { getByRole } = render(Button)
  getByRole('button')
})
// type
// button type defalut should be secondary
test('test button default type', () => {
  const { getByRole } = render(Button)
  const button = getByRole('button')
  expect(button.classList.contains('s-btn--secondary')).toBe(true)
})
// test button pass props type
test('test button pass props type', () => {
  const { getByRole } = render(Button, {
    props: {
      type: 'primary'
    }
  })
  const button = getByRole('button')
  expect(button.classList.contains('s-btn--primary')).toBe(true)
})

// slot
// slot default should be right
test('test slot default should be right', () => {
  const { getByText } = render(Button)
  getByText('按钮')
})
// slot should work
test('slot should work', () => {
  const { getByText } = render(Button, {
    slots: {
      default() {
        return 'inslot'
      }
    }
  })
  getByText('inslot')
})

```

###  / index.ts

```ts
import { App } from 'vue'

import Button from './src/button'

// 具名导出
export { Button }

// 导出插件
export default {
  install(app: App) {
    app.component(Button.name, Button)
  }
}
```



## 整体的scss

### 安装tailwind

```scss
npm install -D tailwindcss
npx tailwindcss init
```

修改根目录下的`tailwind.config.js`文件

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  // Add the paths to all of your template files in your tailwind.config.js file.
  content: ['./public/index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  theme: {
    extend: {}
  },
  plugins: []
}
```

Add the Tailwind directives to your CSS。在根路径的 index.scss中（main.ts对index.scss做引入）

```scss
// @import "tailwindcss/base";
// @import "tailwindcss/components";
// @import "tailwindcss/utilities";
@tailwind base;
@tailwind components;
@tailwind utilities;
```



### $变量

在整个项目的`src/style/variable.scss`下

```scss
// 变量
$prefix: 's';
$spacing-3: 6px;
// 定义主题变量
$s-border-radius: var(--s-border-radius, 2px); //一般圆角
$s-font-size-sm: var(--s-font-size-md, 10px); //当组件size为''时使用此字号大小
// 使用变量
$size-mini: $size-6;
// 线性
$transition-timing-function-linear: cubic-bezier(0, 0, 1, 1);
```

用以上的方法定义了很多的变量，之后在其他的scss文件中可以引入，使用变量：

```scss
@import '../../style/variable.scss';
xxx {
  border-radius: $s-border-radius;
}
```

### mixin 

**用`mixin`定义样式块 `button-base ` ( 配合了 `tailwindcss `)**

```scss
@import '../../style/variable.scss';
@mixin button-base {
  // 布局
  @apply inline-flex items-center justify-center;
  // 元素
  @apply border-[1px] border-solid border-transparent
  h-[28px] py-0 px-[20px]
  bg-transparent;
  border-radius: $s-border-radius;

  // 文本属性
  @apply outline-0 leading-normal whitespace-nowrap
    cursor-pointer;

  // 文字样式
  font-size: $s-font-size-md;

  // 其他样式
  transition: background-color $s-animation-duration-slow
      $s-animation-ease-in-out-smooth,
    border-color $s-animation-duration-slow $s-animation-ease-in-out-smooth,
    color $s-animation-duration-slow $s-animation-ease-in-out-smooth;

  // 禁用状态
  &[disabled] {
    @apply cursor-not-allowed;
  }

  &.s-btn--block {
    @apply block w-full;
  }
  &.s-btn--loading {
    // @apply
  }
}
```

使用`button-base`

```scss
@import './button-base.scss';
.s-btn {
  @include button-base;
}
```

**用mixin定义函数**

```scss
@import '../../style/variable.scss';
@mixin button-variant($variant, $pseudo: false) {
  @each $key, $value in $variant {
    // 第一层是多态的类型
    &.s-btn--#{$key} {
      @each $item-key, $item-value in $value {
        // 第二层是多态类型下的样式
        @if $pseudo {
          // 如果是伪类就继续第三层
          &:#{$item-key} {
            @each $sub-item-key, $sub-item-value in $item-value {
              // 第三层是伪类的样式
              #{$sub-item-key}: $sub-item-value;
            }
          }
        } @else {
          // 不是伪类就直接设置样式
          #{$item-key}: $item-value;
        }
      }
    }
  }
}
```

使用 `button-variant`  函数

```scss
@use './button-config.scss';
@import './button-base.scss';

.s-btn {
  // 导入type相关的样式
  @include button-variant(button-config.$type);
  // 导入size相关的样式
  @include button-variant(button-config.$size);
  // 导入hover等伪类
  @include button-variant(button-config.$pseudo, true);
}
// 文件名如果不以下划线开头的话，sass会认为改文件是一个应用文件，不会将它转成css文件
//  @import "_main.css";
```

可以看到，这里面还有个`@use`和`button-config`变量

### @use

```scss
// 所有不同type按钮自定义样式
@import '../../style/variable.scss';
// 按钮类型的配置
$type: (
  primary: (
    color: $s-light-text,
    background-color: $s-primary
  ),
  secondary: (
    color: $s-text,
    background-color: $s-block,
    border-color: $s-line
  ),
  text: (
    padding: 0,
    color: $s-brand-active
  )
);
// 伪类配置
$pseudo: (
  primary: (
    hover: (
      background-color: $s-primary-hover
    ),
    focus: (
      background-color: $s-primary-hover
    ),
    active: (
      background-color: $s-primary-active
    ),
    disabled: (
      color: $s-light-text,
      background-color: $s-primary-disabled,
      border: none
    )
  ),
  secondary: (...),
  text: (...)
)
// 按钮尺寸
$size: (
  small: (
    height: 24px,
    padding: 0 16px,
    font-size: $s-font-size-sm
  ),
  medium: (...),
  large: (...)
);
```



## button

### props

首先 button 有 三种类型：

```ts
'primary' | 'secondary' | 'text'

export type IButtonType = 'primary' | 'secondary' | 'text'
type: {
  type: String as PropType<IButtonType>,
  default: 'secondary'
},
```

三种 大小 size：

```css
'small' | 'medium' | 'large'
```

能够控制，是否接收被点击：

```ts
disabled: {
  type: Boolean,
  default: false
}
```

如果是手机端，需要按钮够长，为一个 block

```ts
block: {
  type: Boolean,
  default: false
}
```

### code

```css
toRefs(props) 解构下，再把拿到的属性，根据逻辑需要，在tsx中处理
没有其他事件处理，没监听没emit
button按钮中显示的文字做个slot，其他无
```



## form

### 使用

```html
<GForm
  ref="loginFormRef"
  :model="model"
  layout="horizontal"
  :label-align="labelAlign"
  :label-size="labelSize"
  :rules="rules"
  @form-submit="onLogin"
>
  <GFormItem label="用户名：" field="user">
    <GInput v-model="model.user" />
  </GFormItem>
  <GFormItem label="密码：" field="password">
    <GInput v-model="model.password" type="password" />
  </GFormItem>
  <GFormItem>
    <button>登录</button>
  </GFormItem>
</GForm>

```

### props

```ts
import { Rules } from 'async-validator'
import { ExtractPropTypes, InjectionKey, PropType } from 'vue'
import { FormItemContext } from './components/form-item-type'
export type LayoutType = 'vertical' | 'horizontal'
export type LabelSizeType = 'sm' | 'md' | 'lg'
export type LabelAlignType = 'start' | 'center' | 'end'

export const formProps = {
  // 表单数据
  model: {
    type: Object,
    required: true
  },
  // layout、labelSize、labelAlign均为提供给form-item的值
  layout: {
    type: String as PropType<LayoutType>,
    default: 'vertical'
  },
  labelSize: {
    type: String as PropType<LabelSizeType>,
    default: 'md'
  },
  labelAlign: {
    type: String as PropType<LabelAlignType>,
    default: 'start'
  },
  // 校验规则
  rules: {
    type: Object as PropType<Rules>
  }
} as const
export type FormProps = ExtractPropTypes<typeof formProps>
// form组件provide给form-item的ctx类型（提供表单上下文 以及 全局校验）
export type FormContext = {
  model: any
  rules?: Rules
  addItem: (item: FormItemContext) => void
  deleteItem: (item: FormItemContext) => void
}
// 在他provide的时候进行强类型传递
export const formContextToken: InjectionKey<FormContext> =
  Symbol('formContextToken')

```



### code

```tsx
import { Value } from 'async-validator'
import { computed, defineComponent, provide, toRefs } from 'vue'
import { FormItemContext } from './components/form-item-type'
import { formContextToken, FormProps, formProps } from './form-type'

export default defineComponent({
  name: 'GForm',
  props: formProps,
  emits: ['form-submit'],
  setup(props: FormProps, { slots, emit, expose }) {
    const { model } = toRefs(props)
    // 提供 labelData
    const labelData = computed(() => ({
      layout: props.layout,
      labelSize: props.labelSize,
      labelAlign: props.labelAlign
    }))
    provide('LabelData', labelData)
    // 提供表单上下文 以及 全局校验
    const formItems = new Set<FormItemContext>()
    const addItem = (item: FormItemContext) => formItems.add(item)
    const deleteItem = (item: FormItemContext) => formItems.delete(item)
    provide(formContextToken, {
      model: props.model,
      rules: props.rules,
      addItem,
      deleteItem
    })
    const formSubmit = (event: Event) => {
      // 取消表单默认提交行为，防止页面刷新
      event.preventDefault()
      emit('form-submit')
    }
    const validateFormData = (cb: (isCheckSuccess: boolean) => void) => {
      const resArr: Array<Promise<Value>> = []
      formItems.forEach(item => resArr.push(item.validate()))
      Promise.all(resArr)
        .then(() => cb(true))
        .catch(() => cb(false))
    }
    // 对外暴露接口
    expose({
      validateFormData
    })
    return () => (
      <form class="s-form" onSubmit={formSubmit}>
        <div>{model.value.name}</div>
        <div>{slots.default?.()}</div>
      </form>
    )
  }
})

```





### form-item

#### 使用

```html
<GFormItem label="用户名: " field="user"></GFormItem>
```



#### props

```ts
import { Value } from 'async-validator'
import { ExtractPropTypes } from 'vue'
import { LabelAlignType, LabelSizeType, LayoutType } from '../form-type'

export const formItemProps = {
  // 提示label
  label: {
    type: String,
    default: ''
  },
  // 字段属性名
  field: {
    type: String
  }
} as const
export type FormItemProps = ExtractPropTypes<typeof formItemProps>

/*
  export type LayoutType = 'vertical' | 'horizontal'
  export type LabelSizeType = 'sm' | 'md' | 'lg'
  export type LabelAlignType = 'start' | 'center' | 'end'
*/
export type LabelDataType = {
  layout: LayoutType
  labelSize: LabelSizeType
  labelAlign: LabelAlignType
}
// 表单provide传下的对象，含校验方法
export type FormItemContext = {
  validate: () => Promise<Value>
}
```



#### code

```tsx
import {
  computed,
  ComputedRef,
  defineComponent,
  inject,
  onMounted,
  onUnmounted,
  provide,
  ref
} from 'vue'
import { formContextToken } from '../form-type'
import { FormItemProps, formItemProps, LabelDataType } from './form-item-type'
import Validator from 'async-validator'

export default defineComponent({
  name: 'GFormItem',
  props: formItemProps,
  setup(props: FormItemProps, { slots }) {
    const labelData = inject('LabelData') as ComputedRef<LabelDataType>
    const itemClasses = computed(() => ({
      's-form-item': true,
      's-form-item--horizontal': labelData.value.layout === 'horizontal',
      's-form-item--vertical': labelData.value.layout === 'vertical'
    }))
    const labelClass = computed(() => ({
      's-form-item-label': true,
      's-form-item-label--vertical': labelData.value.layout === 'vertical',
      /* 水平 才显示 */
      [`s-form-item-label--${labelData.value.labelAlign}`]:
        labelData.value.layout === 'horizontal',
      [`s-form-item-label--${labelData.value.labelSize}`]:
        labelData.value.layout === 'horizontal'
    }))
    const errorMessage = ref('')
    const showMessage = ref(false)
    // form提供，强类型传递，不需要进行断言
    const formCtx = inject(formContextToken)

    const validate = () => {
      if (!formCtx) {
        console.warn('请在Form中使用FormItem')
        return Promise.reject('请在Form中使用FormItem')
      }
      if (!props.field) {
        console.warn('请在FormItem中设置field字段')
        return Promise.reject('请在FormItem中设置field字段')
      }
      // 不需要校验规则
      if (!formCtx.rules) {
        return Promise.resolve({ result: true })
      }
      // 获取校验规则和数值
      const itemRules = formCtx.rules[props.field] || undefined
      if (!itemRules) {
        return Promise.resolve({ result: true })
      }
      const val = formCtx.model[props.field]
      // 校验，返回结果
      // 创建一个校验的实例
      const validator = new Validator({ [props.field]: itemRules })
      return validator.validate({ [props.field]: val }, err => {
        if (err) {
          showMessage.value = true
          errorMessage.value = err[0].message || '校验失败'
        } else {
          showMessage.value = false
          errorMessage.value = ''
        }
      })
    }
    const formItemCtx = { validate }
    provide('FORM_ITEM_CTX', formItemCtx)
    // 全表单校验
    onMounted(() => {
      if (props.field) {
        formCtx?.addItem(formItemCtx)
      }
    })
    onUnmounted(() => {
      if (props.field) {
        formCtx?.deleteItem(formItemCtx)
      }
    })
    return () => {
      return (
        <div class={itemClasses.value}>
          {/* label */}
          <span class={labelClass.value}>{props.label}</span>
          {/* control */}
          <div>{slots.default?.()}</div>
          {/* error */}
          {showMessage.value && (
            <div class="error-message">{errorMessage.value}</div>
          )}
        </div>
      )
    }
  }
})

```





## icon

### 使用

```vue
<!-- 以图标的方式，存到字体中 -->
<GIcon name="facebook" size="40" color="skyblue"></GIcon>
<GIcon name="react" size="30" color="red"></GIcon>
<GIcon name="react" size="30px" color="blue"></GIcon>
<GIcon name="vue" :size="30" color="green"></GIcon>

<!-- name传src -->
<span style="width: 50px; display: inline-block">
  <GIcon name="https://vitejs.dev/logo.svg" width="30"></GIcon>
</span>

<!-- 通过元件的方式引入到页面中，用svg显示（拓展性更强）-->
<GIcon
  element="react"
  size="30"
  color="red"
  style="display: inline-block"
  ></GIcon>
<GIcon
  element="vue"
  size="30px"
  color="blue"
  style="display: inline-block"
  ></GIcon>
<GIcon
  element="webpack"
  size="30px"
  color="blue"
  style="display: inline-block"
  ></GIcon>
```

### props

```ts
import { ExtractPropTypes, PropType } from 'vue'
export const iconProps = {
  name: {
    // icon-vue中的vue
    type: String,
    default: ''
  },
  prefix: {
    // 前缀
    type: String,
    default: 'icon'
  },
  size: {
    // type: String || Number, --- 错误用法,认为是 String
    // type: [String, Number], --- ts报错
    type: [String, Number] as PropType<string | number>,
    default: 'inherit'
  },
  color: {
    type: String,
    default: 'inherit'
  },
  // 元件名，比如vue、react
  element: {
    type: String,
    default: null
  }
} as const
export type IconProps = ExtractPropTypes<typeof iconProps>
```

### code

```tsx
import { computed, defineComponent, toRefs } from 'vue'
import { IconProps, iconProps } from './icon-type'
import '../style/iconfont.js'
import '../style/iconfont.css'

export default defineComponent({
  name: 'GIcon',
  props: iconProps,
  setup(props: IconProps, { attrs }) {
    const { prefix, name, color, element } = toRefs(props)
    // 根据类型，对size做转换
    const size = computed(() => {
      if (typeof props.size === 'string' && props.size !== 'inherit') {
        // 做个简单的格式判断 --- px结尾
        if (!props.size.endsWith('px')) {
          return props.size + 'px'
        }
      } else if (typeof props.size === 'number') {
        return props.size + 'px'
      }
      return props.size
    })
    // svg显示
    /* 
      可以看到我们需要在svg中拿到对应icon的元件，
      而元件，是从iconfont.js中拿到的，
      在我们从官网导出icon项目的时候，生成的js文件
    */
    const svgIcon = (
      <svg
        class="icon"
        style={{
          width: size.value,
          height: size.value
        }}
      >
        {/* <use xlink:href="#icon-vue" fill={color.value}></use> */}
        <use
          xlink:href={`#${prefix.value}-${element.value}`}
          fill={color.value}
        ></use>
      </svg>
    )
    /* 
      下面的 http/https需要事先拿到地址
      iconfont 需要在icon.scss或者iconfont.css中有对应的类的声明
      （实现方式：伪类 content）
    */
    // http/https图片资源
    const imgIcon = (
      <img
        src={props.name}
        style={{
          width: size.value,
          height: 'auto',
          objectFit: 'contain',
          verticalAlign: 'middle'
        }}
        {...attrs}
      ></img>
    )
    // iconfont
    const fontIcon = (
      <span
        class={[prefix.value + 'font', prefix.value + '-' + name.value]}
        style={{ fontSize: size.value, color: color.value }}
      ></span>
    )
    const icon = /http|https/.test(name.value) ? imgIcon : fontIcon
    // 针对外部在GIcon上设置width，希望能在icon上一直生效的问题：
    // 直接return icon，根组件会继承非属性特性，父的width会直接继承，放到icon上
    // 但是如果icon外面包了一层icon_container，width就会不生效。-继承到icon_container上了
    // 所以进行展开非属性特性。---  attrs
    return () => (element.value ? svgIcon : icon)
  }
})
```

上面一开始引入了

```tsx
import '../style/iconfont.js'
import '../style/iconfont.css'
```

这些去阿里巴巴的iconfont，自己创建一个项目，去收集图标

然后选择font class模式下载，解压就行（后面的`.ttf、.woff、.woff2、.json`也是这样来的）

<img src="https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230330230039534.png" alt="image-20230330230039534" style="zoom:80%;" />



## input

### 使用

```vue
<GInput v-model="model.username"/>
<GInput v-model="model.password" type="password" />
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const inputProps = {
  type: {
    type: String,
    default: 'text'
  },
  modelValue: {
    type: String,
    default: ''
  }
} as const
export type InputProps = ExtractPropTypes<typeof inputProps>
```

### code

可以看到除了做个` input`值的 `v-model`，以及`input`原生的`type`看`props`外

就中只有一个 `inject`注入的方法 `formItemCtx` --- `这里可以看form组件，主要用来做表单校验`

```tsx
export default defineComponent({
  name: 'GInput',
  props: inputProps,
  emits: ['update:modelValue'],
  setup(props: InputProps, { emit }) {
    // 注入校验方法
    const formItemCtx = inject('FORM_ITEM_CTX') as FormItemContext

    const onInputCB = (event: Event) => {
      const val = (event.target as HTMLInputElement).value
      /* 后续要做lazy处理 */
      emit('update:modelValue', val)
      formItemCtx.validate()
    }
    return () => {
      return (
        <div class="s-input-wrapper">
          <input
            class="s-input"
            type={props.type}
            value={props.modelValue}
            onInput={onInputCB}
          />
        </div>
      )
    }
  }
})



// scss
.s-input {
  margin: 5px 10px 0px 5px;
}
```



## modal

### 使用



### props



### code



## pagination

### 使用



### props



### code



## popover

### 使用



### props



### code



## tabs

### 使用



### props



### code



## tree

### 使用



### props



### code



## virtual-list

### 使用



### props



### code



















