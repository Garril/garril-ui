# Garril-UI组件开发思路

<hr/>



## 组件文件目录结构

<hr/>

```css
以button组件为例，其他组件也都差不多
button
	src
		(像form可能有form-item，就在这里开一个components文件夹)
		button.tsx
		button-type.ts
	style
		button-config.scss
		button.scss
		button-base.scss
	test
		button.test.ts
	index.ts
```



## 组件内容案例 ( button )

<hr/>

以button为例子，展示其组件各个文件大致设计

### / src / button.tsx

```tsx
import { defineComponent, toRefs } from 'vue'
import { ButtonProps, buttonProps } from './button-type'

export default defineComponent({
  name: 'GButton',
  props: buttonProps,
  setup(props: ButtonProps, { slots }) {
    const { type, size, disabled, block } = toRefs(props)
    return () => {
      const defaultSlot = slots.default ? slots.default() : '按钮'
      const blockClass = block.value ? 's-btn--block' : ''
      return (
        <button
          disabled={disabled.value}
          class={`s-btn s-btn--${type.value} s-btn--${size.value} ${blockClass}`}
        >
          {defaultSlot}
        </button>
      )
    }
  }
})

```

### / src / button-type.ts

```ts
import { ExtractPropTypes, PropType } from 'vue'

export type IButtonType = 'primary' | 'secondary' | 'text'
export type IButtonSize = 'small' | 'medium' | 'large'

// button中的props定义
export const buttonProps = {
  type: {
    type: String as PropType<IButtonType>,
    default: 'secondary'
  },
  size: {
    type: String as PropType<IButtonSize>,
    default: 'medium'
  },
  disabled: {
    type: Boolean,
    default: false
  },
  block: {
    type: Boolean,
    default: false
  }
}

// 利用值反推出Button属性类型
export type ButtonProps = ExtractPropTypes<typeof buttonProps>
```

### / style / button.scss

```scss
// button.scss
@use './button-config.scss';
@import './button-base.scss';

.s-btn {
  @include button-base;
  // 导入type相关的样式
  @include button-variant(button-config.$type);
  // 导入size相关的样式
  @include button-variant(button-config.$size);
  // 导入hover等伪类
  @include button-variant(button-config.$pseudo, true);
}
```

### / style / button-base.scss

```scss
// button-base.scss
@import '../../style/variable.scss'; // scss变量定义文件 --- 全局style目录下

@mixin button-base {
  // 布局
  @apply inline-flex items-center justify-center;
  // 元素
  @apply border-[1px] border-solid border-transparent
  h-[28px] py-0 px-[20px]
  bg-transparent;
  border-radius: $s-border-radius;

  // 文本属性
  @apply outline-0 leading-normal whitespace-nowrap
    cursor-pointer;

  // 文字样式
  font-size: $s-font-size-md;

  // 其他样式
  transition: background-color $s-animation-duration-slow
      $s-animation-ease-in-out-smooth,
    border-color $s-animation-duration-slow $s-animation-ease-in-out-smooth,
    color $s-animation-duration-slow $s-animation-ease-in-out-smooth;

  // 禁用状态
  &[disabled] {
    @apply cursor-not-allowed;
  }

  &.s-btn--block {
    @apply block w-full;
  }
  &.s-btn--loading {
    // @apply
  }
}

@mixin button-variant($variant, $pseudo: false) {
  @each $key, $value in $variant {
    // 第一层是多态的类型
    &.s-btn--#{$key} {
      @each $item-key, $item-value in $value {
        // 第二层是多态类型下的样式
        @if $pseudo {
          // 如果是伪类就继续第三层
          &:#{$item-key} {
            @each $sub-item-key, $sub-item-value in $item-value {
              // 第三层是伪类的样式
              #{$sub-item-key}: $sub-item-value;
            }
          }
        } @else {
          // 不是伪类就直接设置样式
          #{$item-key}: $item-value;
        }
      }
    }
  }
}
```

### / style / button-config.scss

```scss
// button-config.scss
// 所有不同type按钮自定义样式
@import '../../style/variable.scss';

// 按钮类型的配置
$type: (
  primary: (
    color: $s-light-text,
    background-color: $s-primary
  ),
  secondary: (
    color: $s-text,
    background-color: $s-block,
    border-color: $s-line
  ),
  text: (
    padding: 0,
    color: $s-brand-active
  )
);

// 伪类的配置
$pseudo: (
  primary: (
    hover: (
      background-color: $s-primary-hover
    ),
    focus: (
      background-color: $s-primary-hover
    ),
    active: (
      background-color: $s-primary-active
    ),
    disabled: (
      color: $s-light-text,
      background-color: $s-primary-disabled,
      border: none
    )
  ),
  secondary: (
    hover: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    focus: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    active: (
      border-color: $s-form-control-line-active,
      color: $s-brand-active
    ),
    disabled: (
      color: $s-disabled-text,
      background-color: $s-disabled-bg,
      border: 1px solid $s-disabled-line
    )
  ),
  text: (
    hover: (
      color: $s-brand-active-focus
    ),
    focus: (
      color: $s-brand-active-focus
    ),
    active: (
      color: $s-brand-active-focus
    ),
    disabled: (
      color: $s-disabled-text
    )
  )
);

// 按钮尺寸
$size: (
  small: (
    height: 24px,
    padding: 0 16px,
    font-size: $s-font-size-sm
  ),
  medium: (
    font-size: $s-font-size-md
  ),
  large: (
    height: 32px,
    padding: 0 24px,
    font-size: $s-font-size-lg
  )
);
```

### / test /  button.test.ts

```ts
import { render } from '@testing-library/vue'
import Button from '../src/button'

// base button
test('test base button,without anything passed', () => {
  const { getByRole } = render(Button)
  getByRole('button')
})
// type
// button type defalut should be secondary
test('test button default type', () => {
  const { getByRole } = render(Button)
  const button = getByRole('button')
  expect(button.classList.contains('s-btn--secondary')).toBe(true)
})
// test button pass props type
test('test button pass props type', () => {
  const { getByRole } = render(Button, {
    props: {
      type: 'primary'
    }
  })
  const button = getByRole('button')
  expect(button.classList.contains('s-btn--primary')).toBe(true)
})

// slot
// slot default should be right
test('test slot default should be right', () => {
  const { getByText } = render(Button)
  getByText('按钮')
})
// slot should work
test('slot should work', () => {
  const { getByText } = render(Button, {
    slots: {
      default() {
        return 'inslot'
      }
    }
  })
  getByText('inslot')
})

```

###  / index.ts

```ts
import { App } from 'vue'

import Button from './src/button'

// 具名导出
export { Button }

// 导出插件
export default {
  install(app: App) {
    app.component(Button.name, Button)
  }
}
```



## 整体的scss

### 安装tailwind

```scss
npm install -D tailwindcss
npx tailwindcss init
```

修改根目录下的`tailwind.config.js`文件

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  // Add the paths to all of your template files in your tailwind.config.js file.
  content: ['./public/index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  theme: {
    extend: {}
  },
  plugins: []
}
```

Add the Tailwind directives to your CSS。在根路径的 index.scss中（main.ts对index.scss做引入）

```scss
// @import "tailwindcss/base";
// @import "tailwindcss/components";
// @import "tailwindcss/utilities";
@tailwind base;
@tailwind components;
@tailwind utilities;
```



### $变量

在整个项目的`src/style/variable.scss`下

```scss
// 变量
$prefix: 's';
$spacing-3: 6px;
// 定义主题变量
$s-border-radius: var(--s-border-radius, 2px); //一般圆角
$s-font-size-sm: var(--s-font-size-md, 10px); //当组件size为''时使用此字号大小
// 使用变量
$size-mini: $size-6;
// 线性
$transition-timing-function-linear: cubic-bezier(0, 0, 1, 1);
```

用以上的方法定义了很多的变量，之后在其他的scss文件中可以引入，使用变量：

```scss
@import '../../style/variable.scss';
xxx {
  border-radius: $s-border-radius;
}
```

### mixin 

**用`mixin`定义样式块 `button-base ` ( 配合了 `tailwindcss `)**

```scss
@import '../../style/variable.scss';
@mixin button-base {
  // 布局
  @apply inline-flex items-center justify-center;
  // 元素
  @apply border-[1px] border-solid border-transparent
  h-[28px] py-0 px-[20px]
  bg-transparent;
  border-radius: $s-border-radius;

  // 文本属性
  @apply outline-0 leading-normal whitespace-nowrap
    cursor-pointer;

  // 文字样式
  font-size: $s-font-size-md;

  // 其他样式
  transition: background-color $s-animation-duration-slow
      $s-animation-ease-in-out-smooth,
    border-color $s-animation-duration-slow $s-animation-ease-in-out-smooth,
    color $s-animation-duration-slow $s-animation-ease-in-out-smooth;

  // 禁用状态
  &[disabled] {
    @apply cursor-not-allowed;
  }

  &.s-btn--block {
    @apply block w-full;
  }
  &.s-btn--loading {
    // @apply
  }
}
```

使用`button-base`

```scss
@import './button-base.scss';
.s-btn {
  @include button-base;
}
```

**用mixin定义函数**

```scss
@import '../../style/variable.scss';
@mixin button-variant($variant, $pseudo: false) {
  @each $key, $value in $variant {
    // 第一层是多态的类型
    &.s-btn--#{$key} {
      @each $item-key, $item-value in $value {
        // 第二层是多态类型下的样式
        @if $pseudo {
          // 如果是伪类就继续第三层
          &:#{$item-key} {
            @each $sub-item-key, $sub-item-value in $item-value {
              // 第三层是伪类的样式
              #{$sub-item-key}: $sub-item-value;
            }
          }
        } @else {
          // 不是伪类就直接设置样式
          #{$item-key}: $item-value;
        }
      }
    }
  }
}
```

使用 `button-variant`  函数

```scss
@use './button-config.scss';
@import './button-base.scss';

.s-btn {
  // 导入type相关的样式
  @include button-variant(button-config.$type);
  // 导入size相关的样式
  @include button-variant(button-config.$size);
  // 导入hover等伪类
  @include button-variant(button-config.$pseudo, true);
}
// 文件名如果不以下划线开头的话，sass会认为改文件是一个应用文件，不会将它转成css文件
//  @import "_main.css";
```

可以看到，这里面还有个`@use`和`button-config`变量

### @use

```scss
// 所有不同type按钮自定义样式
@import '../../style/variable.scss';
// 按钮类型的配置
$type: (
  primary: (
    color: $s-light-text,
    background-color: $s-primary
  ),
  secondary: (
    color: $s-text,
    background-color: $s-block,
    border-color: $s-line
  ),
  text: (
    padding: 0,
    color: $s-brand-active
  )
);
// 伪类配置
$pseudo: (
  primary: (
    hover: (
      background-color: $s-primary-hover
    ),
    focus: (
      background-color: $s-primary-hover
    ),
    active: (
      background-color: $s-primary-active
    ),
    disabled: (
      color: $s-light-text,
      background-color: $s-primary-disabled,
      border: none
    )
  ),
  secondary: (...),
  text: (...)
)
// 按钮尺寸
$size: (
  small: (
    height: 24px,
    padding: 0 16px,
    font-size: $s-font-size-sm
  ),
  medium: (...),
  large: (...)
);
```



## button

### props

首先 button 有 三种类型：

```ts
'primary' | 'secondary' | 'text'

export type IButtonType = 'primary' | 'secondary' | 'text'
type: {
  type: String as PropType<IButtonType>,
  default: 'secondary'
},
```

三种 大小 size：

```css
'small' | 'medium' | 'large'
```

能够控制，是否接收被点击：

```ts
disabled: {
  type: Boolean,
  default: false
}
```

如果是手机端，需要按钮够长，为一个 block

```ts
block: {
  type: Boolean,
  default: false
}
```

### code

```css
toRefs(props) 解构下，再把拿到的属性，根据逻辑需要，在tsx中处理
没有其他事件处理，没监听没emit
button按钮中显示的文字做个slot，其他无
```



## form

### 使用

```html
<GForm
  ref="loginFormRef"
  :model="model"
  layout="horizontal"
  :label-align="labelAlign"
  :label-size="labelSize"
  :rules="rules"
  @form-submit="onLogin"
>
  <GFormItem label="用户名：" field="user">
    <GInput v-model="model.user" />
  </GFormItem>
  <GFormItem label="密码：" field="password">
    <GInput v-model="model.password" type="password" />
  </GFormItem>
  <GFormItem>
    <button>登录</button>
  </GFormItem>
</GForm>

```

### props

```ts
import { Rules } from 'async-validator'
import { ExtractPropTypes, InjectionKey, PropType } from 'vue'
import { FormItemContext } from './components/form-item-type'
export type LayoutType = 'vertical' | 'horizontal'
export type LabelSizeType = 'sm' | 'md' | 'lg'
export type LabelAlignType = 'start' | 'center' | 'end'

export const formProps = {
  // 表单数据
  model: {
    type: Object,
    required: true
  },
  // layout、labelSize、labelAlign均为提供给form-item的值
  layout: {
    type: String as PropType<LayoutType>,
    default: 'vertical'
  },
  labelSize: {
    type: String as PropType<LabelSizeType>,
    default: 'md'
  },
  labelAlign: {
    type: String as PropType<LabelAlignType>,
    default: 'start'
  },
  // 校验规则
  rules: {
    type: Object as PropType<Rules>
  }
} as const
export type FormProps = ExtractPropTypes<typeof formProps>
// form组件provide给form-item的ctx类型（提供表单上下文 以及 全局校验）
export type FormContext = {
  model: any
  rules?: Rules
  addItem: (item: FormItemContext) => void
  deleteItem: (item: FormItemContext) => void
}
// 在他provide的时候进行强类型传递
export const formContextToken: InjectionKey<FormContext> =
  Symbol('formContextToken')

```



### code

```tsx
import { Value } from 'async-validator'
import { computed, defineComponent, provide, toRefs } from 'vue'
import { FormItemContext } from './components/form-item-type'
import { formContextToken, FormProps, formProps } from './form-type'

export default defineComponent({
  name: 'GForm',
  props: formProps,
  emits: ['form-submit'],
  setup(props: FormProps, { slots, emit, expose }) {
    const { model } = toRefs(props)
    // 提供 labelData
    const labelData = computed(() => ({
      layout: props.layout,
      labelSize: props.labelSize,
      labelAlign: props.labelAlign
    }))
    provide('LabelData', labelData)
    // 提供表单上下文 以及 全局校验
    const formItems = new Set<FormItemContext>()
    const addItem = (item: FormItemContext) => formItems.add(item)
    const deleteItem = (item: FormItemContext) => formItems.delete(item)
    provide(formContextToken, {
      model: props.model,
      rules: props.rules,
      addItem,
      deleteItem
    })
    const formSubmit = (event: Event) => {
      // 取消表单默认提交行为，防止页面刷新
      event.preventDefault()
      emit('form-submit')
    }
    const validateFormData = (cb: (isCheckSuccess: boolean) => void) => {
      const resArr: Array<Promise<Value>> = []
      formItems.forEach(item => resArr.push(item.validate()))
      Promise.all(resArr)
        .then(() => cb(true))
        .catch(() => cb(false))
    }
    // 对外暴露接口
    expose({
      validateFormData
    })
    return () => (
      <form class="s-form" onSubmit={formSubmit}>
        <div>{model.value.name}</div>
        <div>{slots.default?.()}</div>
      </form>
    )
  }
})

```





### form-item

#### 使用

```html
<GFormItem label="用户名: " field="user"></GFormItem>
```



#### props

```ts
import { Value } from 'async-validator'
import { ExtractPropTypes } from 'vue'
import { LabelAlignType, LabelSizeType, LayoutType } from '../form-type'

export const formItemProps = {
  // 提示label
  label: {
    type: String,
    default: ''
  },
  // 字段属性名
  field: {
    type: String
  }
} as const
export type FormItemProps = ExtractPropTypes<typeof formItemProps>

/*
  export type LayoutType = 'vertical' | 'horizontal'
  export type LabelSizeType = 'sm' | 'md' | 'lg'
  export type LabelAlignType = 'start' | 'center' | 'end'
*/
export type LabelDataType = {
  layout: LayoutType
  labelSize: LabelSizeType
  labelAlign: LabelAlignType
}
// 表单provide传下的对象，含校验方法
export type FormItemContext = {
  validate: () => Promise<Value>
}
```



#### code

```tsx
import {
  computed,
  ComputedRef,
  defineComponent,
  inject,
  onMounted,
  onUnmounted,
  provide,
  ref
} from 'vue'
import { formContextToken } from '../form-type'
import { FormItemProps, formItemProps, LabelDataType } from './form-item-type'
import Validator from 'async-validator'

export default defineComponent({
  name: 'GFormItem',
  props: formItemProps,
  setup(props: FormItemProps, { slots }) {
    const labelData = inject('LabelData') as ComputedRef<LabelDataType>
    const itemClasses = computed(() => ({
      's-form-item': true,
      's-form-item--horizontal': labelData.value.layout === 'horizontal',
      's-form-item--vertical': labelData.value.layout === 'vertical'
    }))
    const labelClass = computed(() => ({
      's-form-item-label': true,
      's-form-item-label--vertical': labelData.value.layout === 'vertical',
      /* 水平 才显示 */
      [`s-form-item-label--${labelData.value.labelAlign}`]:
        labelData.value.layout === 'horizontal',
      [`s-form-item-label--${labelData.value.labelSize}`]:
        labelData.value.layout === 'horizontal'
    }))
    const errorMessage = ref('')
    const showMessage = ref(false)
    // form提供，强类型传递，不需要进行断言
    const formCtx = inject(formContextToken)

    const validate = () => {
      if (!formCtx) {
        console.warn('请在Form中使用FormItem')
        return Promise.reject('请在Form中使用FormItem')
      }
      if (!props.field) {
        console.warn('请在FormItem中设置field字段')
        return Promise.reject('请在FormItem中设置field字段')
      }
      // 不需要校验规则
      if (!formCtx.rules) {
        return Promise.resolve({ result: true })
      }
      // 获取校验规则和数值
      const itemRules = formCtx.rules[props.field] || undefined
      if (!itemRules) {
        return Promise.resolve({ result: true })
      }
      const val = formCtx.model[props.field]
      // 校验，返回结果
      // 创建一个校验的实例
      const validator = new Validator({ [props.field]: itemRules })
      return validator.validate({ [props.field]: val }, err => {
        if (err) {
          showMessage.value = true
          errorMessage.value = err[0].message || '校验失败'
        } else {
          showMessage.value = false
          errorMessage.value = ''
        }
      })
    }
    const formItemCtx = { validate }
    provide('FORM_ITEM_CTX', formItemCtx)
    // 全表单校验
    onMounted(() => {
      if (props.field) {
        formCtx?.addItem(formItemCtx)
      }
    })
    onUnmounted(() => {
      if (props.field) {
        formCtx?.deleteItem(formItemCtx)
      }
    })
    return () => {
      return (
        <div class={itemClasses.value}>
          {/* label */}
          <span class={labelClass.value}>{props.label}</span>
          {/* control */}
          <div>{slots.default?.()}</div>
          {/* error */}
          {showMessage.value && (
            <div class="error-message">{errorMessage.value}</div>
          )}
        </div>
      )
    }
  }
})

```





## icon

### 使用

```vue
<!-- 以图标的方式，存到字体中 -->
<GIcon name="facebook" size="40" color="skyblue"></GIcon>
<GIcon name="react" size="30" color="red"></GIcon>
<GIcon name="react" size="30px" color="blue"></GIcon>
<GIcon name="vue" :size="30" color="green"></GIcon>

<!-- name传src -->
<span style="width: 50px; display: inline-block">
  <GIcon name="https://vitejs.dev/logo.svg" width="30"></GIcon>
</span>

<!-- 通过元件的方式引入到页面中，用svg显示（拓展性更强）-->
<GIcon
  element="react"
  size="30"
  color="red"
  style="display: inline-block"
  ></GIcon>
<GIcon
  element="vue"
  size="30px"
  color="blue"
  style="display: inline-block"
  ></GIcon>
<GIcon
  element="webpack"
  size="30px"
  color="blue"
  style="display: inline-block"
  ></GIcon>
```

### props

```ts
import { ExtractPropTypes, PropType } from 'vue'
export const iconProps = {
  name: {
    // icon-vue中的vue
    type: String,
    default: ''
  },
  prefix: {
    // 前缀
    type: String,
    default: 'icon'
  },
  size: {
    // type: String || Number, --- 错误用法,认为是 String
    // type: [String, Number], --- ts报错
    type: [String, Number] as PropType<string | number>,
    default: 'inherit'
  },
  color: {
    type: String,
    default: 'inherit'
  },
  // 元件名，比如vue、react
  element: {
    type: String,
    default: null
  }
} as const
export type IconProps = ExtractPropTypes<typeof iconProps>
```

### code

```tsx
import { computed, defineComponent, toRefs } from 'vue'
import { IconProps, iconProps } from './icon-type'
import '../style/iconfont.js'
import '../style/iconfont.css'

export default defineComponent({
  name: 'GIcon',
  props: iconProps,
  setup(props: IconProps, { attrs }) {
    const { prefix, name, color, element } = toRefs(props)
    // 根据类型，对size做转换
    const size = computed(() => {
      if (typeof props.size === 'string' && props.size !== 'inherit') {
        // 做个简单的格式判断 --- px结尾
        if (!props.size.endsWith('px')) {
          return props.size + 'px'
        }
      } else if (typeof props.size === 'number') {
        return props.size + 'px'
      }
      return props.size
    })
    // svg显示
    /* 
      可以看到我们需要在svg中拿到对应icon的元件，
      而元件，是从iconfont.js中拿到的，
      在我们从官网导出icon项目的时候，生成的js文件
    */
    const svgIcon = (
      <svg
        class="icon"
        style={{
          width: size.value,
          height: size.value
        }}
      >
        {/* <use xlink:href="#icon-vue" fill={color.value}></use> */}
        <use
          xlink:href={`#${prefix.value}-${element.value}`}
          fill={color.value}
        ></use>
      </svg>
    )
    /* 
      下面的 http/https需要事先拿到地址
      iconfont 需要在icon.scss或者iconfont.css中有对应的类的声明
      （实现方式：伪类 content）
    */
    // http/https图片资源
    const imgIcon = (
      <img
        src={props.name}
        style={{
          width: size.value,
          height: 'auto',
          objectFit: 'contain',
          verticalAlign: 'middle'
        }}
        {...attrs}
      ></img>
    )
    // iconfont
    const fontIcon = (
      <span
        class={[prefix.value + 'font', prefix.value + '-' + name.value]}
        style={{ fontSize: size.value, color: color.value }}
      ></span>
    )
    const icon = /http|https/.test(name.value) ? imgIcon : fontIcon
    // 针对外部在GIcon上设置width，希望能在icon上一直生效的问题：
    // 直接return icon，根组件会继承非属性特性，父的width会直接继承，放到icon上
    // 但是如果icon外面包了一层icon_container，width就会不生效。-继承到icon_container上了
    // 所以进行展开非属性特性。---  attrs
    return () => (element.value ? svgIcon : icon)
  }
})
```

上面一开始引入了

```tsx
import '../style/iconfont.js'
import '../style/iconfont.css'
```

这些去阿里巴巴的iconfont，自己创建一个项目，去收集图标

然后选择font class模式下载，解压就行（后面的`.ttf、.woff、.woff2、.json`也是这样来的）

<img src="https://forupload.oss-cn-guangzhou.aliyuncs.com/newImg/image-20230330230039534.png" alt="image-20230330230039534" style="zoom:80%;" />



## input

### 使用

```vue
<GInput v-model="model.username"/>
<GInput v-model="model.password" type="password" />
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const inputProps = {
  type: {
    type: String,
    default: 'text'
  },
  modelValue: {
    type: String,
    default: ''
  }
} as const
export type InputProps = ExtractPropTypes<typeof inputProps>
```

### code

可以看到除了做个` input`值的 `v-model`，以及`input`原生的`type`看`props`外

就中只有一个 `inject`注入的方法 `formItemCtx` --- `这里可以看form组件，主要用来做表单校验`

```tsx
export default defineComponent({
  name: 'GInput',
  props: inputProps,
  emits: ['update:modelValue'],
  setup(props: InputProps, { emit }) {
    // 注入校验方法
    const formItemCtx = inject('FORM_ITEM_CTX') as FormItemContext

    const onInputCB = (event: Event) => {
      const val = (event.target as HTMLInputElement).value
      /* 后续要做lazy处理 */
      emit('update:modelValue', val)
      formItemCtx.validate()
    }
    return () => {
      return (
        <div class="s-input-wrapper">
          <input
            class="s-input"
            type={props.type}
            value={props.modelValue}
            onInput={onInputCB}
          />
        </div>
      )
    }
  }
})



// scss
.s-input {
  margin: 5px 10px 0px 5px;
}
```



## modal

`modal`的`render`直接就是套了一个`base-modal`，而`base-modal`只有一个`slots.default()`

这下面的 `template header/footer`，都是在`modal`中定义的

可以看到，在用的时候，`header`有提供 `close` 函数，待改进：给`footer`也提供

不过控制是否显示隐藏，是从最外层传给`modal`的`visible`到`base-modal`中的`isShow`。

### 使用

```html
<GModal v-model="visible" title="提示" :show-close="false" align-center>
  <template #header="{ close }">
    <div class="my-header"
         style="display: flex;
                justify-content: space-between;
                padding: 0 20px">
      <h4>My slot title!</h4>
      <GButton type="danger" @click="close">Close</GButton>
    </div>
  </template>
  <span>this is a message!</span>
  <template #footer>
    <div>
      <GButton style="margin-right: 12px" @click="visible = false">quit</GButton>
      <GButton @click="visible = false">yes</GButton>
    </div>
  </template>
</GModal>
<GButton @click="open"></GButton>

<!-- script部分 -->
const visible = ref(false)
const open = () => {
  visible.value = true
}
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const modalProps = {
  modelValue: {
    // 是否展示
    type: Boolean,
    default: false
  },
  title: {
    // 标题
    type: String,
    default: ''
  },
  width: {
    // 弹框的宽度
    type: String,
    default: '30%'
  },
  showClose: {
    // 显示关闭 x
    type: Boolean,
    default: true
  },
  center: {
    // title居中 -- 没用slots.header的情况下
    type: Boolean,
    default: false
  },
  alignCenter: {
    // modal整体 竖直方向居中
    type: Boolean,
    default: false
  }
} as const
export type ModalProps = ExtractPropTypes<typeof modalProps>
```

### code

```ts
import { defineComponent, toRefs } from 'vue'
import BaseModal from './components/base-modal'
import { ModalProps, modalProps } from './modal-type'

export default defineComponent({
  name: 'GModal',
  props: modalProps,
  emits: ['update:modelValue'],
  setup(props: ModalProps, { slots, emit }) {
    const { modelValue, title, width, showClose, center, alignCenter } =
      toRefs(props)
    const alignCenterStyle = alignCenter.value
      ? {
          marginTop: 0,
          top: '50%',
          transform: 'translateY(-50%)'
        }
      : {}
    return () => (
      <BaseModal
        class="s-modal"
        isShow={modelValue.value}
        onUpdate:isShow={() => {
          emit('update:modelValue')
        }}
      >
        <div
          class="s-modal-container"
          style={{ width: width.value, ...alignCenterStyle }}
        >
          {/* 标题title */}
          {slots.header ? (
            slots.header?.({
              close: () => {
                emit('update:modelValue', false)
              }
            })
          ) : (
            <div
              class="s-modal-header"
              style={{ textAlign: center.value ? 'center' : 'left' }}
            >
              {title.value}
              {/* 关闭modal的 X 号*/}
              {showClose.value && (
                <svg
                  onClick={() => {
                    emit('update:modelValue', false)
                  }}
                  class="s-modal-close"
                  viewBox="0 0 1024 1024"
                  width="16"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    fill="currentColor"
                    d="M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
                  ></path>
                </svg>
              )}
            </div>
          )}
          {/* 内容default */}
          <div class="s-modal-default">{slots.default?.()}</div>
          {/* 操作区footer */}
          <div class="s-modal-footer">{slots.footer?.()}</div>
        </div>
      </BaseModal>
    )
  }
})

```

### base-modal

#### 使用

```css
modal的render就是return了一个base-modal,具体使用看Modal即可
```

#### props

```ts
import { ExtractPropTypes } from 'vue'

export const baseModalProps = {
  isShow: {
    // 是否展示
    type: Boolean,
    default: false
  }
} as const
export type BaseModalProps = ExtractPropTypes<typeof baseModalProps>
```

#### code

```ts
import { defineComponent, toRefs } from 'vue'
import { baseModalProps, BaseModalProps } from './base-modal-type'

export default defineComponent({
  name: 'GBaseModal',
  props: baseModalProps,
  emits: ['update:isShow'],
  setup(props: BaseModalProps, { slots, emit }) {
    const { isShow } = toRefs(props)
    return () => (
      <div>
        {isShow.value && (
          <div class="s-base-modal">
            {/* 透明遮罩 */}
            <div
              class="s-base-modal--mask"
              onClick={() => {
                emit('update:isShow', false)
              }}
            ></div>
            {/* 具体内容 */}
            {slots.default?.()}
          </div>
        )}
      </div>
    )
  }
})
```

#### scss 

```scss
.s-base-modal,
.s-base-modal--mask {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  z-index: 100;
}
.s-base-modal--mask {
  background-color: rgba(0, 0, 0, 0.6);
  z-index: -1;
}
```



## pagination

### 使用

其实下面的` pagination`和`pager`差别为：

`pagination` 比 `pager `多出了个 上一页和下一页的功能

```html
<GPagination v-model:curPageIndex="curIndex" :total="50"></GPagination>
<GPager :total="50" @update-pager-index="changeIndex"></GPager>
```

### props

```ts
import { ExtractPropTypes } from 'vue'

export const paginationProps = {
  total: {
    // data总条数
    type: Number,
    default: 10
  },
  pageSize: {
    // 每页最大条数
    type: Number,
    default: 5
  },
  pageCount: {
    // 底部显示的页数按钮 数量
    type: Number,
    default: 5
  },
  curPageIndex: {
    type: Number,
    default: 1
  }
} as const
export type PaginationProps = ExtractPropTypes<typeof paginationProps>
```

### code

```ts
import { computed, defineComponent, onMounted, ref, toRefs, watch } from 'vue'
import Pager from './components/pager'
import { PaginationProps, paginationProps } from './pagination-type'

export default defineComponent({
  name: 'GPagination',
  props: paginationProps,
  emits: ['update:curPageIndex'],
  setup(props: PaginationProps, { emit }) {
    const { total, pageSize } = toRefs(props)
    const pagerRef = ref<InstanceType<typeof Pager>>()
    const calcTotalPage = computed(() => {
      return Math.ceil(total.value / pageSize.value)
    })
    const disablePre = computed(() =>
      pagerRef.value ? pagerRef.value.pageIndex < 2 : true
    )
    const disableNext = computed(() =>
      pagerRef.value ? pagerRef.value.pageIndex >= calcTotalPage.value : true
    )
    /* 可以知道，页面号是Pager组件，Pagination是加了外面的上一页和下一页
    	然后Pager中pageIndex改变，emit到Pagination，Pagination再emit -- update:curPageIndex
    	外面v-modal到Pagination组件上的数据变化了，相当于传入Pagination组件的props改变了
    	那么，这里就会反而再通过组件ref，去改变Pager中的index。
    	
    	这也是为什么，在Pager组件中，我没有直接在setup函数中去return我的jsx
    	而是return出去数据和方法，这样父组件Pagination才能通过ref来调用。
    	之前的jsx从新在render函数中写就行。
    */
    const changePageIndex = (val: any) => {
      emit('update:curPageIndex', val)
    }
    onMounted(() => {
      watch(
        () => props.curPageIndex,
        (newVal: number) => {
          if (pagerRef.value) {
            pagerRef.value.setPageIndex(newVal)
          }
        }
      )
    })
    return () => {
      return (
        <div class="s-pagination">
        // 上一页按钮
          <button
            onClick={() => pagerRef.value?.prePage(calcTotalPage.value)}
            disabled={disablePre.value}
          >
            上一页
          </button>
				// 页号按钮
          <Pager
            {...props}
            ref={pagerRef}
					// 当pageIndex变化，Pager就会emit发送updatePagerIndex事件
            onUpdatePagerIndex={(val: any) => changePageIndex(val)}
          ></Pager>
				 // 下一页按钮
          <button
            onClick={() => pagerRef.value?.nextPage(calcTotalPage.value)}
            disabled={disableNext.value}
          >
            下一页
          </button>
        </div>
      )
    }
  }
})

```



### pager

#### hooks

封装当前页面index的相关prepage、nextPage等方法

```ts
import { ref } from 'vue'

export default function usePage(defaultPageIndex = 1) {
  // page number
  const pageIndex = ref(defaultPageIndex)
  // set page number -- click numbers to jump
  const setPageIndex = (cur: number) => {
    pageIndex.value = cur
  }
  // jump how many pages to ( double arrow -- quick to or back )
  const jumpToPageIndex = (step: number, calcTotalPage?: number) => {
    let res = pageIndex.value + step
    if (calcTotalPage && res > calcTotalPage) {
      res = calcTotalPage
    } else if (res < 1) {
      res = 1
    }
    pageIndex.value = res
  }
  // previous page
  const prePage = (calcTotalPage: number) => {
    jumpToPageIndex(-1, calcTotalPage)
  }
  // next page
  const nextPage = (calcTotalPage: number) => {
    jumpToPageIndex(1, calcTotalPage)
  }
  return {
    pageIndex,
    setPageIndex,
    jumpToPageIndex,
    prePage,
    nextPage
  }
}
```



#### props

`pagination` 和 `pager`的`props`一样

```ts
import { ExtractPropTypes } from 'vue'
import { paginationProps } from '../pagination-type'

export const pagerProps = paginationProps
// total--data总条数、pageSize--每页最大条数、
// pageCount--底部显示的页数按钮 数量、curPageIndex--当前页码
export type PagerProps = ExtractPropTypes<typeof pagerProps>
```

#### code

```ts
import { computed, defineComponent, toRefs, watch } from 'vue'
import usePage from '../hooks/use-page'
import { getCenterPage } from '../utils'
import { pagerProps, PagerProps } from './pager-type'

export default defineComponent({
  name: 'GPager',
  props: pagerProps,
  emits: ['updatePagerIndex'],
  setup(props: PagerProps, { emit }) {
    const { pageIndex, setPageIndex, jumpToPageIndex, nextPage, prePage } =
      usePage()
    const { total, pageSize, pageCount } = toRefs(props)
    // 计算当前多少页
    const calcTotalPage = computed(() => {
      // 向上取整
      return Math.ceil(total.value / pageSize.value)
    })
    // 当前显示在中间的页（不包含首页、末页）
    const centerPages = computed(() => {
      return getCenterPage(
        calcTotalPage.value,
        pageIndex.value,
        pageCount.value
      )
    })
    watch(
      () => pageIndex.value,
      newVal => {
        emit('updatePagerIndex', newVal)
      }
    )
    return {
      pageCount,
      calcTotalPage,
      centerPages,
      pageIndex,
      setPageIndex,
      jumpToPageIndex,
      nextPage,
      prePage
    }
  },
  render() {
    const {
      pageCount,
      calcTotalPage,
      centerPages,
      pageIndex,
      setPageIndex,
      jumpToPageIndex
    } = this
    // 别写箭头函数
    return (
      <ul class="s-pager">
       // 首页
        <li
          onClick={() => setPageIndex(1)}
          class={{ current: pageIndex === 1 }}
        >
          1
        </li>
				// 点击中间的...，就向前/向后跳5页，改变了pageIndex,进而
        // 触发了centerPages的变化，emit了事件updatePagerIndex
        {calcTotalPage > pageCount && pageIndex > Math.ceil(pageCount / 2) && (
          <li
            class="ellipsis_left"
            onClick={() => jumpToPageIndex(-5, calcTotalPage)}
          >
            ...
          </li>
        )}
        {centerPages.map(page => (
          <li
            onClick={() => setPageIndex(page)}
            class={{ current: pageIndex === page }}
          >
            {page}
          </li>
        ))}
        {calcTotalPage > pageCount &&
          pageIndex < calcTotalPage - Math.ceil(pageCount / 2) + 1 && (
            <li
              class="ellipsis_right"
              onClick={() => jumpToPageIndex(5, calcTotalPage)}
            >
              ...
            </li>
          )}
          // 末页
        {calcTotalPage > 1 && (
          <li
            onClick={() => setPageIndex(calcTotalPage)}
            class={{ current: pageIndex === calcTotalPage }}
          >
            {calcTotalPage}
          </li>
        )}
      </ul>
    )
  }
})
```

#### utils

```ts
export function getCenterPage(
  calcTotalPage: number, // 计算出的总页码
  pageIndex: number, // 当前页码
  pageCount: number // 底部显示的页数按钮 数量
) {
  // ！！！ 首页和尾页 两个按钮固定显示，且数组代表页码 ！！！
  // 所以0不要，而且末页页码不在数组中
  const totalPageArr = Array.from({ length: calcTotalPage }, (v, i) => i)
  // eg: calcTotalPage = 5 --> totalPageArr: [0,1,2,3,4]
  if (calcTotalPage <= pageCount) {
    // eg: calcTotalPage = 5，totalPageArr = [0,1,2,3,4], pageCount = 6
    // 要取 [2,3,4]，1是首页，5是末页
    // 全显示
    return totalPageArr.slice(2, calcTotalPage)
  } else {
    // 中位数
    const mid = Math.ceil(pageCount / 2) // 注意：是pageCount
    // totalPageArr = [0,1,2,3,4,5,6,7,8]，calcTotalPage = 9, pageCount = 7 --> mid = 4
    if (pageIndex <= mid) {
      // pageIndex = 2/3/4
      // 要取[2,3,4,5,6] ---> slice(2,7)
      // 左边全显示
      return totalPageArr.slice(2, pageCount)
    } else if (pageIndex >= calcTotalPage - mid + 1) {
      // pageIndex = 6/7/8 (与前面不同，前面1是首位不能取，这里8不是末尾可取)
      // 要取[4,5,6,7,8]  ---> slice(4,9)
      // 右边全显示
      return totalPageArr.slice(calcTotalPage - pageCount + 2, calcTotalPage)
    } else {
      // pageIndex = 5
      // 要取[3,4,5,6,7] ---> slice(3,8)
      // 中间显示
      return totalPageArr.slice(pageIndex - mid + 2, pageIndex + mid - 1)
    }
  }
}

```



## popover

### 使用

```html

```



### props



### code



### base-popover

#### props



#### code





## tabs

### 使用



### props



### code



## tree

### 使用



### props



### code



## virtual-list

### 使用



### props



### code



















